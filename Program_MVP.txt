from pathlib import Path
import sqlite3
import hashlib
import csv
from datetime import datetime
import calendar

import tkinter as tk
from tkinter import ttk, messagebox, filedialog

import ttkbootstrap as ttkb

# PDF / Excel
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from reportlab.lib.units import cm
from openpyxl import Workbook

# Graphics
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import numpy as np


# PATHS

BASE_DIR = Path(__file__).resolve().parent
DB_DIR = BASE_DIR / "db"
DB_PATH = DB_DIR / "database.db"


# DB HELPERS

def db_connect():
    DB_DIR.mkdir(parents=True, exist_ok=True)
    conn = sqlite3.connect(DB_PATH)
    conn.execute("PRAGMA foreign_keys = ON;")
    return conn


def hash_password(password: str) -> str:
    return hashlib.sha256(password.encode("utf-8")).hexdigest()


def now_iso():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")


def ensure_tables_and_seed():
    conn = db_connect()
    cur = conn.cursor()

    # ETUDIANTS
    cur.execute("""
        CREATE TABLE IF NOT EXISTS etudiants (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            matricule TEXT UNIQUE NOT NULL,
            nom TEXT NOT NULL,
            prenom TEXT NOT NULL,
            date_naissance TEXT,
            lieu_naissance TEXT,
            sexe TEXT,
            telephone TEXT,
            adresse TEXT,
            photo_path TEXT,
            email TEXT UNIQUE,
            statut TEXT DEFAULT 'actif',
            date_inscription TEXT
        );
    """)

    # FILIÈRES
    cur.execute("""
        CREATE TABLE IF NOT EXISTS filieres (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            code TEXT UNIQUE NOT NULL,
            nom TEXT NOT NULL
        );
    """)

    # NIVEAUX
    cur.execute("""
        CREATE TABLE IF NOT EXISTS niveaux (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            code TEXT UNIQUE NOT NULL,
            nom TEXT NOT NULL,
            ordre INTEGER
        );
    """)

    # INSCRIPTIONS
    cur.execute("""
        CREATE TABLE IF NOT EXISTS inscriptions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            etudiant_id INTEGER NOT NULL,
            filiere_id INTEGER NOT NULL,
            niveau_id INTEGER NOT NULL,
            groupe_id INTEGER,
            annee_academique TEXT NOT NULL,
            statut TEXT DEFAULT 'inscrit',
            date_inscription TEXT,
            FOREIGN KEY(etudiant_id) REFERENCES etudiants(id) ON DELETE CASCADE,
            FOREIGN KEY(filiere_id) REFERENCES filieres(id) ON DELETE RESTRICT,
            FOREIGN KEY(niveau_id) REFERENCES niveaux(id) ON DELETE RESTRICT,
            FOREIGN KEY(groupe_id) REFERENCES groupes(id) ON DELETE SET NULL
        );
    """)

    # MODULES
    cur.execute("""
        CREATE TABLE IF NOT EXISTS modules (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            code TEXT UNIQUE NOT NULL,
            nom TEXT NOT NULL,
            coefficient REAL NOT NULL,
            credits INTEGER,
            semestre TEXT,
            filiere_id INTEGER,
            niveau_id INTEGER,
            FOREIGN KEY(filiere_id) REFERENCES filieres(id) ON DELETE SET NULL,
            FOREIGN KEY(niveau_id) REFERENCES niveaux(id) ON DELETE SET NULL
        );
    """)

    # NOTES
    cur.execute("""
        CREATE TABLE IF NOT EXISTS notes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            etudiant_id INTEGER NOT NULL,
            module_id INTEGER NOT NULL,
            note REAL NOT NULL,
            type_evaluation TEXT,
            annee_academique TEXT,
            FOREIGN KEY(etudiant_id) REFERENCES etudiants(id) ON DELETE CASCADE,
            FOREIGN KEY(module_id) REFERENCES modules(id) ON DELETE CASCADE
        );
    """)

    # AUDIT
    cur.execute("""
        CREATE TABLE IF NOT EXISTS notes_audit (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            note_id INTEGER NOT NULL,
            action TEXT NOT NULL,
            old_value TEXT,
            new_value TEXT,
            changed_at TEXT NOT NULL,
            changed_by TEXT NOT NULL,
            FOREIGN KEY(note_id) REFERENCES notes(id) ON DELETE CASCADE
        );
    """)

    # ABSENCES
    cur.execute("""
        CREATE TABLE IF NOT EXISTS absences (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            etudiant_id INTEGER NOT NULL,
            module_id INTEGER NOT NULL,
            date_absence TEXT NOT NULL,
            justifiee INTEGER DEFAULT 0,
            motif TEXT,
            FOREIGN KEY(etudiant_id) REFERENCES etudiants(id) ON DELETE CASCADE,
            FOREIGN KEY(module_id) REFERENCES modules(id) ON DELETE CASCADE
        );
    """)

    # ENSEIGNANT 
    cur.execute("""
        CREATE TABLE IF NOT EXISTS enseignants (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            nom TEXT NOT NULL,
            prenom TEXT NOT NULL,
            email TEXT UNIQUE
        );
    """)

    cur.execute("""
        CREATE TABLE IF NOT EXISTS enseignements (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            enseignant_id INTEGER NOT NULL,
            module_id INTEGER NOT NULL,
            annee_academique TEXT,
            UNIQUE(enseignant_id, module_id, annee_academique),
            FOREIGN KEY(enseignant_id) REFERENCES enseignants(id) ON DELETE CASCADE,
            FOREIGN KEY(module_id) REFERENCES modules(id) ON DELETE CASCADE
        );
    """)

    # CALENDRIER 
    cur.execute("""
        CREATE TABLE IF NOT EXISTS semestres (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            code TEXT UNIQUE NOT NULL,
            libelle TEXT,
            date_debut TEXT NOT NULL,
            date_fin TEXT NOT NULL
        );
    """)

    cur.execute("""
        CREATE TABLE IF NOT EXISTS periodes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            semestre_id INTEGER NOT NULL,
            type TEXT NOT NULL,
            libelle TEXT,
            date_debut TEXT NOT NULL,
            date_fin TEXT NOT NULL,
            FOREIGN KEY(semestre_id) REFERENCES semestres(id) ON DELETE CASCADE
        );
    """)

    # login/users - ENRICHED
    cur.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE NOT NULL,
            password_hash TEXT NOT NULL,
            role TEXT NOT NULL,
            nom TEXT,
            prenom TEXT,
            email TEXT UNIQUE,
            date_creation TEXT,
            actif INTEGER DEFAULT 1
        );
    """)

    # NEW TABLES

    # specialites
    cur.execute("""
        CREATE TABLE IF NOT EXISTS specialites (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            filiere_id INTEGER NOT NULL,
            nom TEXT NOT NULL,
            description TEXT,
            FOREIGN KEY(filiere_id) REFERENCES filieres(id) ON DELETE CASCADE
        );
    """)

    # groupes
    cur.execute("""
        CREATE TABLE IF NOT EXISTS groupes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            code TEXT UNIQUE NOT NULL,
            nom TEXT NOT NULL,
            filiere_id INTEGER,
            niveau_id INTEGER,
            FOREIGN KEY(filiere_id) REFERENCES filieres(id) ON DELETE SET NULL,
            FOREIGN KEY(niveau_id) REFERENCES niveaux(id) ON DELETE SET NULL
        );
    """)

    # LOGS (audit trail)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            action TEXT NOT NULL,
            table_affectee TEXT,
            enregistrement_id INTEGER,
            details TEXT,
            date_action TEXT NOT NULL,
            FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE SET NULL
        );
    """)

    # PARAMETRES (configuration)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS parametres (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            cle TEXT UNIQUE NOT NULL,
            valeur TEXT NOT NULL,
            description TEXT,
            type_donnee TEXT
        );
    """)

    # SEED ADMIN IF NONE
    try:
        cur.execute("SELECT COUNT(*) FROM users;")
        user_count = cur.fetchone()[0]
    except Exception as e:
        print(f"Erreur vérification users: {e}")
        user_count = 0
    
    if user_count == 0:
        try:
            cur.execute("""
                INSERT INTO users (username, password_hash, role, nom, prenom, date_creation, actif)
                VALUES (?, ?, ?, ?, ?, ?, 1);
            """, ("admin", hash_password("admin123"), "ADMIN", "Admin", "Système", now_iso()))
            print("✓ Utilisateur admin créé avec succès")
        except Exception as e:
            print(f"Erreur création admin: {e}")

    try:
        conn.commit()
        print("✓ Base de données initialisée avec succès")
    except Exception as e:
        print(f"Erreur commit: {e}")
    finally:
        conn.close()
    
    # Appliquer les migrations
    migrate_database()
    
    # Seed les groupes par défaut
    seed_groupes_defaults()


def migrate_database():
    """Ajoute les colonnes manquantes à la table etudiants si nécessaire"""
    conn = db_connect()
    cur = conn.cursor()
    
    try:
        # Vérifier les colonnes existantes
        cur.execute("PRAGMA table_info(etudiants)")
        existing_columns = {row[1] for row in cur.fetchall()}
        
        # Colonnes requises
        required_columns = {
            'date_naissance', 'lieu_naissance', 'sexe', 
            'telephone', 'adresse', 'photo_path', 'date_inscription'
        }
        
        # Ajouter les colonnes manquantes
        for col in required_columns:
            if col not in existing_columns:
                try:
                    if col == 'date_inscription':
                        cur.execute(f"ALTER TABLE etudiants ADD COLUMN {col} TEXT")
                    elif col == 'telephone':
                        cur.execute(f"ALTER TABLE etudiants ADD COLUMN {col} TEXT")
                    elif col == 'adresse':
                        cur.execute(f"ALTER TABLE etudiants ADD COLUMN {col} TEXT")
                    elif col == 'photo_path':
                        cur.execute(f"ALTER TABLE etudiants ADD COLUMN {col} TEXT")
                    elif col == 'sexe':
                        cur.execute(f"ALTER TABLE etudiants ADD COLUMN {col} TEXT DEFAULT 'M'")
                    else:
                        cur.execute(f"ALTER TABLE etudiants ADD COLUMN {col} TEXT")
                    print(f"Colonne {col} ajoutée à la table etudiants")
                except Exception as e:
                    print(f"Colonne {col} existe déjà ou erreur: {e}")
        
        conn.commit()
        print("Migration base de données complétée")
    except Exception as e:
        print(f"Erreur migration: {e}")
    finally:
        conn.close()

    # Vérifier la table des enseignements pour ajouter la colonne 'groupe' si nécessaire
    conn = db_connect()
    cur = conn.cursor()
    try:
        cur.execute("PRAGMA table_info(enseignements)")
        existing = {row[1] for row in cur.fetchall()}
        if 'groupe' not in existing:
            try:
                cur.execute("ALTER TABLE enseignements ADD COLUMN groupe TEXT")
                conn.commit()
                print("Colonne 'groupe' ajoutée à la table enseignements")
            except Exception as e:
                print(f"Impossible d'ajouter la colonne 'groupe' : {e}")
    except Exception:
        pass
    finally:
        conn.close()

    # Vérifier la table modules pour ajouter la colonne 'semestre' si nécessaire
    conn = db_connect()
    cur = conn.cursor()
    try:
        cur.execute("PRAGMA table_info(modules)")
        existing = {row[1] for row in cur.fetchall()}
        if 'semestre' not in existing:
            try:
                cur.execute("ALTER TABLE modules ADD COLUMN semestre TEXT")
                conn.commit()
                print("Colonne 'semestre' ajoutée à la table modules")
            except Exception as e:
                print(f"Impossible d'ajouter la colonne 'semestre' : {e}")
    except Exception:
        pass
    finally:
        conn.close()


def seed_groupes_defaults():
    """Insérer les groupes par défaut s'il n'y en a pas"""
    conn = db_connect()
    cur = conn.cursor()
    
    try:
        # Vérifier si des groupes existent déjà
        cur.execute("SELECT COUNT(*) FROM groupes")
        count = cur.fetchone()[0]
        
        if count == 0:
            # Insérer des groupes par défaut
            groupes_defaults = [
                ("GR-A1", "Groupe A1"),
                ("GR-A2", "Groupe A2"),
                ("GR-B1", "Groupe B1"),
                ("GR-B2", "Groupe B2"),
                ("GR-C1", "Groupe C1"),
                ("GR-C2", "Groupe C2"),
            ]
            for code, nom in groupes_defaults:
                try:
                    cur.execute("INSERT INTO groupes (code, nom) VALUES (?, ?)", (code, nom))
                except sqlite3.IntegrityError:
                    pass  # Déjà existe
            
            conn.commit()
            print("Groupes par défaut créés avec succès")
    except Exception as e:
        print(f"Erreur création groupes par défaut: {e}")
    finally:
        conn.close()


def log_action(conn, user_id: int, action: str, table_affectee: str, enregistrement_id: int = None, details: str = None):
    """Enregistre une action dans la table logs pour l'audit"""
    cur = conn.cursor()
    cur.execute("""
        INSERT INTO logs (user_id, action, table_affectee, enregistrement_id, details, date_action)
        VALUES (?, ?, ?, ?, ?, ?)
    """, (user_id, action, table_affectee, enregistrement_id, details, now_iso()))
    conn.commit()


def calculate_academic_honors(average: float) -> str:
    """Calcule la mention académique en fonction de la moyenne
    
    Échelle:
    - Excellente: >= 18/20
    - Très bien: >= 16/20
    - Bien: >= 14/20
    - Assez bien: >= 12/20
    - Passable: >= 10/20
    - Insuffisant: < 10/20
    """
    if average >= 18:
        return "Excellente"
    elif average >= 16:
        return "Très bien"
    elif average >= 14:
        return "Bien"
    elif average >= 12:
        return "Assez bien"
    elif average >= 10:
        return "Passable"
    else:
        return "Insuffisant"


def get_student_average(etudiant_id: int, annee_academique: str = None) -> tuple:
    """Récupère la moyenne générale d'un étudiant
    
    Retourne: (moyenne, mention, nombre_notes)
    """
    conn = db_connect()
    cur = conn.cursor()
    
    if annee_academique:
        cur.execute("""
            SELECT AVG(note) FROM notes 
            WHERE etudiant_id=? AND annee_academique=?
        """, (etudiant_id, annee_academique))
    else:
        cur.execute("SELECT AVG(note) FROM notes WHERE etudiant_id=?", (etudiant_id,))
    
    avg_result = cur.fetchone()[0]
    moyenne = float(avg_result) if avg_result else 0.0
    
    # Compter le nombre de notes
    if annee_academique:
        cur.execute("""
            SELECT COUNT(*) FROM notes 
            WHERE etudiant_id=? AND annee_academique=?
        """, (etudiant_id, annee_academique))
    else:
        cur.execute("SELECT COUNT(*) FROM notes WHERE etudiant_id=?", (etudiant_id,))
    
    count = cur.fetchone()[0]
    conn.close()
    
    mention = calculate_academic_honors(moyenne)
    return (round(moyenne, 2), mention, count)


# DATA - COUNTRIES

COUNTRIES = [
    "Afghanistan", "Afrique du Sud", "Albanie", "Algérie", "Allemagne", "Andorre", "Angola", 
    "Anguilla", "Antarctique", "Antigua-et-Barbuda", "Arabie saoudite", "Argentine", "Arménie",
    "Aruba", "Australie", "Autriche", "Azerbaïdjan", "Bahamas", "Bahreïn", "Bangladesh",
    "Barbade", "Belgique", "Belize", "Bénin", "Bermudes", "Bhoutan", "Biélorussie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie",
    "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie", "Birmanie"
]

# Liste de pays
COUNTRIES = [
    "Afghanistan", "Afrique du Sud", "Albanie", "Algérie", "Allemagne", "Andorre", "Angola", 
    "Anguilla", "Antarctique", "Antigua-et-Barbuda", "Arabie saoudite", "Argentine", "Arménie",
    "Aruba", "Australie", "Autriche", "Azerbaïdjan", "Bahamas", "Bahreïn", "Bangladesh",
    "Barbade", "Belgique", "Belize", "Bénin", "Bermudes", "Bhoutan", "Biélorussie",
    "Birmanie", "Biélorussie", "Bosnie-Herzégovine", "Botswana", "Brésil", "Brunei",
    "Bulgarie", "Burkina Faso", "Burundi", "Cambodge", "Cameroun", "Canada", "Cap-Vert",
    "Chili", "Chine", "Chypre", "Colombie", "Comores", "Congo", "Corée du Nord", "Corée du Sud",
    "Costa Rica", "Côte d'Ivoire", "Croatie", "Cuba", "Curaçao", "Danemark", "Djibouti",
    "Dominique", "Égypte", "Émirats Arabes Unis", "Équateur", "Érythrée", "Espagne",
    "Estonie", "États-Unis", "Éthiopie", "Fidji", "Finlande", "France", "Gabon", "Gambie",
    "Géorgie", "Ghana", "Gibraltar", "Grèce", "Grenade", "Groenland", "Guadeloupe",
    "Guam", "Guatemala", "Guernesey", "Guinée", "Guinée équatoriale", "Guinée-Bissau",
    "Guyana", "Guyane française", "Haïti", "Honduras", "Hong Kong", "Hongrie", "Île Bouvet",
    "Île Christmas", "Île Norfolk", "Îles Åland", "Îles Caïmans", "Îles Cocos", "Îles Féroé",
    "Îles Heard et MacDonald", "Îles Malouines", "Îles Mariannes du Nord", "Îles Marshall",
    "Îles Pitcairn", "Îles Salomon", "Îles Turques-et-Caïques", "Îles Vierges britanniques",
    "Îles Vierges des États-Unis", "Inde", "Indonésie", "Irak", "Iran", "Irlande",
    "Irlande du Nord", "Islande", "Israël", "Italie", "Jamaïque", "Japon", "Jersey",
    "Jordanie", "Kazakhstan", "Kenya", "Kirghizistan", "Kiribati", "Koweït", "Laos",
    "Lesotho", "Lettonie", "Liban", "Liberia", "Libye", "Liechtenstein", "Lituanie",
    "Luxembourg", "Macao", "Macédoine", "Madagascar", "Malaisie", "Malawi", "Maldives",
    "Mali", "Malte", "Maroc", "Martinique", "Mauritanie", "Maurice", "Mauritius",
    "Mayotte", "Mexique", "Micronésie", "Moldavie", "Moluques", "Monaco", "Mongolie",
    "Monténégro", "Montserrat", "Mozambique", "Namibie", "Nauru", "Népal", "Nicaragua",
    "Niger", "Nigeria", "Niue", "Norvège", "Nouvelle-Calédonie", "Nouvelle-Zélande",
    "Oman", "Ouganda", "Ouzbékistan", "Pakistan", "Palaos", "Palestine", "Panama",
    "Papouasie-Nouvelle-Guinée", "Pâques", "Paraguay", "Pays-Bas", "Pérou", "Pérou",
    "Philippines", "Pologne", "Polynésie française", "Porto Rico", "Portugal", "Provence",
    "Qatar", "La Réunion", "République Centrafricaine", "République du Congo",
    "République Démocratique du Congo", "République Dominicaine", "République Tchèque",
    "Roumanie", "Royaume-Uni", "Russie", "Rwanda", "Sahara occidental", "Sahara occidental",
    "Saint-Barthélemy", "Saint-Marin", "Saint-Martin", "Saint-Pierre-et-Miquelon",
    "Sainte-Hélène", "Sainte-Lucie", "Samoa", "Samoa américaines", "Sao Tomé et Principe",
    "Sénégal", "Serbie", "Seychelles", "Sierra Leone", "Singapour", "Sint Maarten",
    "Slovaquie", "Slovénie", "Somalie", "Somaliland", "Soudan", "Soudan du Sud",
    "Sri Lanka", "Suède", "Suisse", "Suriname", "Svalbard et Jan Mayen", "Swaziland",
    "Syrie", "Tadjikistan", "Taïwan", "Tanzanie", "Tchad", "Terres australes françaises",
    "Territoire britannique de l'océan Indien", "Territoire palestinien occupé", "Thaïlande",
    "Timor oriental", "Togo", "Tokelau", "Tonga", "Trinité-et-Tobago", "Tristan da Cunha",
    "Tunisie", "Turkménistan", "Turquie", "Tuvalu", "Ukraine", "Uruguayay", "Vanuatu",
    "Vatican", "Venezuela", "Viêt Nam", "Wallis et Futuna", "Yémen", "Zambie", "Zimbabwe"
]

# Valider le format téléphone international
def validate_phone(phone: str) -> bool:
    """Valide un numéro de téléphone format international: +XXX XXXXXXXXXX"""
    if not phone:
        return False
    # Accepter que des chiffres et +, -, espaces
    phone = phone.replace(" ", "").replace("-", "")
    return len(phone) >= 10 and phone[0] == '+' and phone[1:].isdigit()

def format_phone_hint() -> str:
    return "Format: +XXX XXXXXXXXXX (ex: +33 612345678)"


# EXPORT HELPERS

def export_query_to_xlsx(headers, rows, filepath: str, sheet_name="Export"):
    wb = Workbook()
    ws = wb.active
    ws.title = sheet_name[:31]
    ws.append(headers)
    for r in rows:
        ws.append(list(r))
    Path(filepath).parent.mkdir(parents=True, exist_ok=True)
    wb.save(filepath)


def _pdf_header(c, title: str):
    c.setFont("Helvetica-Bold", 16)
    c.drawString(2 * cm, 28.5 * cm, title)
    c.setFont("Helvetica", 10)
    c.drawString(2 * cm, 28.0 * cm, f"Généré le {datetime.now().strftime('%Y-%m-%d %H:%M')}")


def generate_transcript_pdf(conn, etudiant_id: int, filepath: str):
    cur = conn.cursor()
    cur.execute("SELECT matricule, nom, prenom, COALESCE(email,'') FROM etudiants WHERE id=?", (etudiant_id,))
    etu = cur.fetchone()
    if not etu:
        raise ValueError("Étudiant introuvable")

    Path(filepath).parent.mkdir(parents=True, exist_ok=True)
    c = canvas.Canvas(filepath, pagesize=A4)
    _pdf_header(c, "Relevé de notes")

    matricule, nom, prenom, email = etu
    c.setFont("Helvetica", 11)
    c.drawString(2 * cm, 26.8 * cm, f"Étudiant : {nom} {prenom}")
    c.drawString(2 * cm, 26.2 * cm, f"Matricule : {matricule}")
    if email:
        c.drawString(2 * cm, 25.6 * cm, f"Email : {email}")

    cur.execute("""
        SELECT m.code, m.nom, m.coefficient, no.note, COALESCE(no.annee_academique,''), COALESCE(no.type_evaluation,'')
        FROM notes no
        JOIN modules m ON m.id = no.module_id
        WHERE no.etudiant_id=?
        ORDER BY COALESCE(no.annee_academique,''), m.code
    """, (etudiant_id,))
    rows = cur.fetchall()

    y = 24.5 * cm
    c.setFont("Helvetica-Bold", 10)
    c.drawString(2 * cm, y, "Module")
    c.drawString(10 * cm, y, "Coef")
    c.drawString(12 * cm, y, "Note")
    c.drawString(14 * cm, y, "Année")
    y -= 0.6 * cm

    c.setFont("Helvetica", 10)
    total_points = 0.0
    total_coef = 0.0

    for code, mnom, coef, note, annee, typ in rows:
        if y < 2.5 * cm:
            c.showPage()
            _pdf_header(c, "Relevé de notes (suite)")
            y = 26.5 * cm
            c.setFont("Helvetica", 10)

        c.drawString(2 * cm, y, f"{code} - {mnom}"[:60])
        c.drawString(10 * cm, y, f"{coef}")
        c.drawString(12 * cm, y, f"{note}")
        c.drawString(14 * cm, y, annee)
        y -= 0.5 * cm

        try:
            total_points += float(note) * float(coef)
            total_coef += float(coef)
        except Exception:
            pass

    y -= 0.4 * cm
    c.setFont("Helvetica-Bold", 11)
    if total_coef > 0:
        moyenne = total_points / total_coef
        mention = calculate_academic_honors(moyenne)
        c.drawString(2 * cm, y, f"Moyenne générale : {moyenne:.2f} / 20")
        y -= 0.5 * cm
        c.drawString(2 * cm, y, f"Mention : {mention}")
    else:
        c.drawString(2 * cm, y, "Moyenne générale : -")

    c.save()


def generate_attestation_pdf(conn, etudiant_id: int, annee: str, filepath: str):
    cur = conn.cursor()
    cur.execute("SELECT matricule, nom, prenom FROM etudiants WHERE id=?", (etudiant_id,))
    etu = cur.fetchone()
    if not etu:
        raise ValueError("Étudiant introuvable")

    cur.execute("""
        SELECT f.code, f.nom, n.code, n.nom, COALESCE(i.statut,'')
        FROM inscriptions i
        JOIN filieres f ON f.id=i.filiere_id
        JOIN niveaux n ON n.id=i.niveau_id
        WHERE i.etudiant_id=? AND i.annee_academique=?
        ORDER BY i.id DESC
        LIMIT 1
    """, (etudiant_id, annee))
    ins = cur.fetchone()
    if not ins:
        raise ValueError("Aucune inscription pour cette année")

    matricule, nom, prenom = etu
    fcode, fnom, ncode, nnom, statut = ins

    Path(filepath).parent.mkdir(parents=True, exist_ok=True)
    c = canvas.Canvas(filepath, pagesize=A4)
    _pdf_header(c, "Attestation de scolarité")

    c.setFont("Helvetica", 12)
    text = c.beginText(2 * cm, 25.5 * cm)
    text.textLine("Je soussigné(e), certifie que :")
    text.textLine("")
    text.textLine(f"{nom} {prenom} (matricule : {matricule})")
    text.textLine("")
    text.textLine(f"est inscrit(e) pour l'année académique : {annee}")
    text.textLine(f"Filière : {fcode} - {fnom}")
    text.textLine(f"Niveau : {ncode} - {nnom}")
    text.textLine(f"Statut : {statut}")
    text.textLine("")
    text.textLine("Fait pour servir et valoir ce que de droit.")
    c.drawText(text)

    c.setFont("Helvetica", 10)
    c.drawString(2 * cm, 4 * cm, "Signature : ____________________________")

    c.save()


# DATE PICKER WIDGET

class DatePickerEntry(ttk.Frame):
    """Three-field date input (Day / Month / Year) using Spinbox with validation.

    Keeps the previous public API: `get() -> 'YYYY-MM-DD' or ''`, `set(value)`, `delete(start, end)`.
    """
    def __init__(self, parent, year_range=(1900, 2100), **kwargs):
        super().__init__(parent)

        self._year_min, self._year_max = year_range

        # Vars
        self.day_var = tk.StringVar()
        self.month_var = tk.StringVar()
        self.year_var = tk.StringVar()

        today = datetime.now()
        self.day_var.set(f"{today.day:02d}")
        self.month_var.set(f"{today.month:02d}")
        self.year_var.set(str(today.year))

        # Validation commands
        vcmd_day = (self.register(self._validate_numeric), '%P', 'day')
        vcmd_month = (self.register(self._validate_numeric), '%P', 'month')
        vcmd_year = (self.register(self._validate_numeric), '%P', 'year')

        # Spinboxes
        self.spin_day = tk.Spinbox(self, from_=1, to=31, width=3, textvariable=self.day_var,
                                   validate='key', validatecommand=vcmd_day, command=self._on_spin_change)
        self.spin_month = tk.Spinbox(self, from_=1, to=12, width=3, textvariable=self.month_var,
                                     validate='key', validatecommand=vcmd_month, command=self._on_spin_change)
        self.spin_year = tk.Spinbox(self, from_=self._year_min, to=self._year_max, width=5, textvariable=self.year_var,
                                    validate='key', validatecommand=vcmd_year, command=self._on_spin_change)

        # Layout
        self.spin_day.pack(side='left')
        ttk.Label(self, text='/').pack(side='left', padx=(2,2))
        self.spin_month.pack(side='left')
        ttk.Label(self, text='/').pack(side='left', padx=(2,2))
        self.spin_year.pack(side='left')

        # Trace changes to adjust day limits when month/year change
        self.month_var.trace_add('write', lambda *a: self._adjust_day_limit())
        self.year_var.trace_add('write', lambda *a: self._adjust_day_limit())

    # --- Validation helpers
    def _validate_numeric(self, proposed, field):
        # Allow empty while typing
        if proposed == "":
            return True
        if not proposed.isdigit():
            return False
        try:
            val = int(proposed)
        except ValueError:
            return False

        if field == 'day':
            return 1 <= val <= 31
        if field == 'month':
            return 1 <= val <= 12
        if field == 'year':
            return self._year_min <= val <= self._year_max
        return False

    def _on_spin_change(self):
        # Called when spin arrows are used — ensure day fits month/year
        self._adjust_day_limit()

    def _adjust_day_limit(self):
        # Compute max day for current month/year and update spinbox range
        try:
            month = int(self.month_var.get())
            year = int(self.year_var.get())
        except Exception:
            return
        if not (1 <= month <= 12):
            return

        max_day = calendar.monthrange(year, month)[1]
        # Update spinbox 'to' option
        try:
            self.spin_day.config(to=max_day)
        except Exception:
            pass

        # Clamp current day if necessary
        try:
            day = int(self.day_var.get())
            if day > max_day:
                self.day_var.set(f"{max_day:02d}")
        except Exception:
            # if empty or invalid, set to 1
            self.day_var.set('01')

    # --- Public API
    def get(self):
        try:
            d = int(self.day_var.get())
            m = int(self.month_var.get())
            y = int(self.year_var.get())
            # validate final date
            max_day = calendar.monthrange(y, m)[1]
            if not (1 <= d <= max_day):
                return ''
            return f"{y:04d}-{m:02d}-{d:02d}"
        except Exception:
            return ''

    def set(self, value):
        # Accept 'YYYY-MM-DD' (ISO). Silently ignore invalids.
        try:
            parts = value.split('-')
            if len(parts) == 3:
                y, m, d = int(parts[0]), int(parts[1]), int(parts[2])
                self.year_var.set(str(y))
                self.month_var.set(f"{m:02d}")
                self.day_var.set(f"{d:02d}")
                self._adjust_day_limit()
        except Exception:
            pass

    def delete(self, start=None, end=None):
        self.day_var.set('')
        self.month_var.set('')
        self.year_var.set('')


# YEAR COMBOBOX WIDGET

class YearCombobox(ttk.Combobox):
    """Combobox for year selection up to current year"""
    def __init__(self, parent, start_year=1980, **kwargs):
        current_year = datetime.now().year
        years = [str(y) for y in range(current_year, start_year - 1, -1)]
        super().__init__(parent, values=years, **kwargs)
        self.set(str(current_year))


# MAIN APP

class App(tk.Toplevel):
    def __init__(self, parent, username: str, root=None):
        super().__init__(parent)
        self.username = username
        self.root = root

        self.title("Gestion des étudiants")
        self.geometry("1400x800")
        self.resizable(True, True)
        
        # Fermer l'application complètement quand on ferme cette fenêtre
        self.protocol("WM_DELETE_WINDOW", self.close_app)
        
        # Permettre le plein écran avec F11
        self.bind("<F11>", self.toggle_fullscreen)
        self.fullscreen_state = False

        self.tabs = ttk.Notebook(self)
        self.tabs.pack(fill="both", expand=True, padx=10, pady=10)

        self.tab_etudiants = ttk.Frame(self.tabs)
        self.tab_academique = ttk.Frame(self.tabs)
        self.tab_inscriptions = ttk.Frame(self.tabs)
        self.tab_notes = ttk.Frame(self.tabs)
        self.tab_absences = ttk.Frame(self.tabs)
        self.tab_enseignants = ttk.Frame(self.tabs)
        self.tab_calendrier = ttk.Frame(self.tabs)
        self.tab_dashboard = ttk.Frame(self.tabs)
        self.tab_documents = ttk.Frame(self.tabs)
        self.tab_users = ttk.Frame(self.tabs)

        # Initialize filter variables BEFORE builds
        self.var_search_name = tk.StringVar()
        self.var_filter_filiere = tk.StringVar()
        self.var_filter_niveau = tk.StringVar()
        self.var_filter_statut = tk.StringVar()
        self.var_filter_groupe = tk.StringVar()

        self.tabs.add(self.tab_etudiants, text="Étudiants")
        self.tabs.add(self.tab_academique, text="Filières & Niveaux")
        self.tabs.add(self.tab_inscriptions, text="Inscriptions")
        self.tabs.add(self.tab_notes, text="Modules & Notes")
        self.tabs.add(self.tab_absences, text="Absences")
        self.tabs.add(self.tab_enseignants, text="Enseignants")
        self.tabs.add(self.tab_calendrier, text="Calendrier")
        self.tabs.add(self.tab_dashboard, text="Dashboard")
        self.tabs.add(self.tab_documents, text="Documents")
        self.tabs.add(self.tab_users, text="Gestion utilisateurs")

        self.build_etudiants_tab()
        self.build_academique_tab()
        self.build_inscriptions_tab()
        self.build_notes_tab()
        self.build_absences_tab()
        self.build_enseignants_tab()
        self.build_calendrier_tab()
        self.build_dashboard_tab()
        self.build_documents_tab()
        self.build_users_tab()

        self.refresh_all()

    # UTIL

    def parse_id_from_combo(self, s: str):
        if not s:
            return None
        part = s.split("-", 1)[0].strip()
        return int(part) if part.isdigit() else None

    def refresh_all(self):
        self.refresh_etudiants_list()
        self.load_filter_options()
        self.refresh_filieres()
        self.refresh_niveaux()
        self.refresh_groupes()
        self.populate_semestres()
        self.refresh_inscriptions_lists()
        self.refresh_modules_list()
        self.refresh_notes_lists()
        self.refresh_absences()
        self.refresh_enseignants()
        self.refresh_calendrier()
        self.refresh_dashboard()
        self.refresh_documents_lists()
        self.refresh_users_list()

    def toggle_fullscreen(self, event=None):
        """Toggle fullscreen mode with F11"""
        self.fullscreen_state = not self.fullscreen_state
        self.attributes('-fullscreen', self.fullscreen_state)

    # ETUDIANTS

    def build_etudiants_tab(self):
        frm = ttk.Frame(self.tab_etudiants, padding=10)
        frm.pack(fill="both", expand=True)

        left = ttk.LabelFrame(frm, text="Ajouter un étudiant", padding=10)
        left.pack(side="left", fill="both", expand=False, padx=(0, 10))

        # INFORMATIONS PERSONNELLES
        ttk.Label(left, text="Nom *").grid(row=0, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Prénom *").grid(row=1, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Email *").grid(row=2, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Téléphone").grid(row=3, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Adresse").grid(row=4, column=0, sticky="w", pady=4)

        self.e_nom = ttk.Entry(left, width=28)
        self.e_prenom = ttk.Entry(left, width=28)
        self.e_email = ttk.Entry(left, width=28)
        self.e_telephone = ttk.Entry(left, width=28)
        self.e_adresse = ttk.Entry(left, width=28)

        self.e_nom.grid(row=0, column=1, pady=4)
        self.e_prenom.grid(row=1, column=1, pady=4)
        self.e_email.grid(row=2, column=1, pady=4)
        self.e_telephone.grid(row=3, column=1, pady=4)
        self.e_adresse.grid(row=4, column=1, pady=4)
        
        # Format hint for phone
        ttk.Label(left, text=format_phone_hint(), font=("", 8)).grid(row=3, column=2, sticky="w", padx=4)

        # INFORMATIONS ACADEMIQUES
        ttk.Label(left, text="Date naissance").grid(row=5, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Sexe").grid(row=6, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Pays de naissance").grid(row=7, column=0, sticky="w", pady=4)

        self.e_date_naissance = DatePickerEntry(left)
        self.var_sexe = tk.StringVar(value="M")
        self.cb_sexe = ttk.Combobox(left, textvariable=self.var_sexe, values=["M", "F", "Autre"], width=25, state="readonly")

        self.e_date_naissance.grid(row=5, column=1, pady=4, sticky="ew")
        self.cb_sexe.grid(row=6, column=1, pady=4)
        
        # Pays de naissance avec recherche dynamique
        self.var_pays = tk.StringVar()
        self.cb_pays = ttk.Combobox(left, textvariable=self.var_pays, values=COUNTRIES, width=25)
        self.cb_pays.grid(row=7, column=1, pady=4)
        self.cb_pays.bind("<KeyRelease>", self.filter_countries)

        # PHOTO
        ttk.Label(left, text="Photo").grid(row=8, column=0, sticky="w", pady=4)
        self.lbl_photo_path = ttk.Label(left, text="Aucune photo", foreground="gray", width=25)
        self.lbl_photo_path.grid(row=8, column=1, pady=4, sticky="w")
        ttk.Button(left, text="Sélectionner", command=self.select_photo_student).grid(row=8, column=2, padx=4)

        # Stocker le chemin de la photo
        self.photo_path_temp = None

        ttk.Button(left, text="Ajouter", command=self.add_etudiant).grid(row=9, column=1, sticky="e", pady=(10, 0))

        ttk.Separator(left, orient="horizontal").grid(row=10, column=0, columnspan=3, sticky="ew", pady=12)

        ttk.Button(left, text="Importer CSV", command=self.import_etudiants_csv).grid(row=11, column=0, columnspan=3, sticky="ew", pady=4)
        ttk.Button(left, text="Exporter CSV", command=self.export_etudiants_csv).grid(row=12, column=0, columnspan=3, sticky="ew", pady=4)
        ttk.Button(left, text="Exporter Excel", command=self.export_etudiants_xlsx).grid(row=13, column=0, columnspan=3, sticky="ew", pady=4)

        right = ttk.LabelFrame(frm, text="Liste des étudiants (double-clic = fiche)", padding=10)
        right.pack(side="left", fill="both", expand=True)

        # FILTRES AVANCÉS
        filter_frame = ttk.LabelFrame(right, text="Filtres avancés", padding=8)
        filter_frame.pack(fill="x", pady=(0, 10))

        ttk.Label(filter_frame, text="Recherche (nom/email):").grid(row=0, column=0, sticky="w", padx=4, pady=4)
        e_search = ttk.Entry(filter_frame, textvariable=self.var_search_name, width=25)
        e_search.grid(row=0, column=1, sticky="ew", padx=4, pady=4)
        e_search.bind("<KeyRelease>", lambda e: self.apply_etudiants_filters())

        ttk.Label(filter_frame, text="Filière:").grid(row=0, column=2, sticky="w", padx=4, pady=4)
        self.cb_filter_filiere = ttk.Combobox(filter_frame, textvariable=self.var_filter_filiere, width=15, state="readonly")
        self.cb_filter_filiere.grid(row=0, column=3, sticky="ew", padx=4, pady=4)
        self.cb_filter_filiere.bind("<<ComboboxSelected>>", lambda e: self.apply_etudiants_filters())

        ttk.Label(filter_frame, text="Niveau:").grid(row=1, column=0, sticky="w", padx=4, pady=4)
        self.cb_filter_niveau = ttk.Combobox(filter_frame, textvariable=self.var_filter_niveau, width=15, state="readonly")
        self.cb_filter_niveau.grid(row=1, column=1, sticky="ew", padx=4, pady=4)
        self.cb_filter_niveau.bind("<<ComboboxSelected>>", lambda e: self.apply_etudiants_filters())

        ttk.Label(filter_frame, text="Statut:").grid(row=1, column=2, sticky="w", padx=4, pady=4)
        self.cb_filter_statut = ttk.Combobox(filter_frame, textvariable=self.var_filter_statut, 
                                            values=["", "actif", "suspendu", "diplômé"], width=15, state="readonly")
        self.cb_filter_statut.grid(row=1, column=3, sticky="ew", padx=4, pady=4)
        self.cb_filter_statut.bind("<<ComboboxSelected>>", lambda e: self.apply_etudiants_filters())

        ttk.Label(filter_frame, text="Groupe:").grid(row=2, column=0, sticky="w", padx=4, pady=4)
        self.cb_filter_groupe = ttk.Combobox(filter_frame, textvariable=self.var_filter_groupe, width=15, state="readonly")
        self.cb_filter_groupe.grid(row=2, column=1, sticky="ew", padx=4, pady=4)
        self.cb_filter_groupe.bind("<<ComboboxSelected>>", lambda e: self.apply_etudiants_filters())

        ttk.Button(filter_frame, text="Réinitialiser", command=self.reset_etudiants_filters).grid(row=2, column=2, columnspan=2, sticky="ew", padx=4, pady=4)

        filter_frame.columnconfigure(1, weight=1)
        filter_frame.columnconfigure(3, weight=1)

        cols = ("id", "matricule", "nom", "prenom", "email", "telephone", "statut")
        self.tree_etudiants = ttk.Treeview(right, columns=cols, show="headings")
        for c in cols:
            self.tree_etudiants.heading(c, text=c)
            if c == "id":
                self.tree_etudiants.column(c, width=50, anchor="center")
            elif c in ("email", "telephone"):
                self.tree_etudiants.column(c, width=140, anchor="w")
            else:
                self.tree_etudiants.column(c, width=120, anchor="w")

        self.tree_etudiants.pack(fill="both", expand=True)
        self.tree_etudiants.bind("<Double-1>", self.open_fiche_etudiant)

        # AJOUT : Barre d'actions de suppression sous la liste
        actions_frame = ttk.Frame(right)
        actions_frame.pack(fill="x", pady=(5, 0))
        
        ttk.Button(actions_frame, text="Supprimer l'étudiant sélectionné", command=self.delete_etudiant, bootstyle="danger").pack(side="right")        

    def generate_matricule(self, nom: str, prenom: str) -> str:
        base = f"ETU{nom[:2].upper()}{prenom[:2].upper()}"
        conn = db_connect()
        cur = conn.cursor()
        i = 1
        matricule = base
        while True:
            cur.execute("SELECT 1 FROM etudiants WHERE matricule = ?", (matricule,))
            if cur.fetchone() is None:
                break
            i += 1
            matricule = f"{base}{i}"
        conn.close()
        return matricule

    def add_etudiant(self):
        nom = self.e_nom.get().strip()
        prenom = self.e_prenom.get().strip()
        email = self.e_email.get().strip()
        telephone = self.e_telephone.get().strip()
        adresse = self.e_adresse.get().strip()
        date_naissance = self.e_date_naissance.get().strip()
        sexe = self.var_sexe.get()
        pays = self.var_pays.get().strip()
        photo_path = self.photo_path_temp

        # Validations
        if not nom or not prenom:
            messagebox.showerror("Erreur", "Nom et prénom obligatoires.")
            return
        
        if not email:
            messagebox.showerror("Erreur", "Email obligatoire.")
            return
        
        if telephone and not validate_phone(telephone):
            messagebox.showerror("Erreur", f"Format téléphone invalide.\n{format_phone_hint()}")
            return

        matricule = self.generate_matricule(nom, prenom)

        conn = db_connect()
        cur = conn.cursor()
        try:
            cur.execute("""
                INSERT INTO etudiants 
                (matricule, nom, prenom, email, telephone, adresse, date_naissance, lieu_naissance, sexe, photo_path, statut, date_inscription) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                matricule, nom, prenom, 
                email, 
                telephone if telephone else None,
                adresse if adresse else None,
                date_naissance if date_naissance else None,
                pays if pays else None,  # <--- C'est la 8ème valeur
                sexe,
                photo_path,
                "actif",
                now_iso()
            ))
            conn.commit()
            print(f"Étudiant ajouté: {matricule} - {nom} {prenom}")
        except sqlite3.IntegrityError as e:
            messagebox.showerror("Erreur", f"Email déjà utilisé ou conflit matricule.\n{str(e)}")
            print(f"Erreur IntegrityError: {e}")
            conn.close()
            return
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de l'ajout: {str(e)}")
            print(f"Erreur générale: {e}")
            conn.close()
            return
        finally:
            if not conn:
                conn.close()

        # Réinitialiser le formulaire
        self.e_nom.delete(0, tk.END)
        self.e_prenom.delete(0, tk.END)
        self.e_email.delete(0, tk.END)
        self.e_telephone.delete(0, tk.END)
        self.e_adresse.delete(0, tk.END)
        self.e_date_naissance.delete(0, tk.END)

        self.var_sexe.set("M")
        self.var_pays.set("")
        self.photo_path_temp = None
        self.lbl_photo_path.config(text="Aucune photo")

        self.refresh_all()
        messagebox.showinfo("OK", f"Étudiant ajouté ({matricule}).")

    def delete_etudiant(self):
        """Supprime l'étudiant sélectionné et ses données liées"""
        sel = self.tree_etudiants.selection()
        if not sel:
            messagebox.showerror("Erreur", "Veuillez sélectionner un étudiant dans la liste de droite.")
            return

        # Récupérer les infos pour le message de confirmation
        values = self.tree_etudiants.item(sel[0], "values")
        etu_id = int(values[0])
        matricule = values[1]
        nom_complet = f"{values[2]} {values[3]}"

        # Demander confirmation
        msg = f"Voulez-vous vraiment supprimer l'étudiant {nom_complet} ({matricule}) ?\n\n" \
              f"ATTENTION : Cela supprimera définitivement ses inscriptions, notes et absences associées."
        
        if not messagebox.askyesno("Confirmation de suppression", msg, icon='warning'):
            return

        # Suppression en base
        conn = db_connect()
        cur = conn.cursor()
        try:
            cur.execute("DELETE FROM etudiants WHERE id=?", (etu_id,))
            conn.commit()
            messagebox.showinfo("Succès", "Étudiant supprimé avec succès.")
        except Exception as e:
            messagebox.showerror("Erreur", f"Impossible de supprimer : {e}")
        finally:
            conn.close()

        # Rafraîchir l'affichage
        self.refresh_all()    

    def select_photo_student(self):
        """Sélectionner une photo pour l'étudiant"""
        path = filedialog.askopenfilename(
            filetypes=[("Images", "*.jpg *.jpeg *.png *.bmp"), ("All Files", "*.*")]
        )
        if path:
            self.photo_path_temp = path
            filename = path.split("\\")[-1]
            self.lbl_photo_path.config(text=filename, foreground="black")

    def filter_countries(self, event=None):
        """Filtre la liste des pays en fonction de la saisie"""
        search = self.var_pays.get().lower()
        if not search:
            self.cb_pays['values'] = COUNTRIES
        else:
            filtered = [c for c in COUNTRIES if c.lower().startswith(search)]
            self.cb_pays['values'] = filtered if filtered else COUNTRIES

    def refresh_etudiants_list(self):
        if not hasattr(self, "tree_etudiants"):
            return
        
        # Vérifier si des filtres sont actifs
        has_active_filters = False
        if hasattr(self, "var_search_name"):
            has_active_filters = (
                self.var_search_name.get().strip() or
                self.var_filter_filiere.get().strip() or
                self.var_filter_niveau.get().strip() or
                self.var_filter_statut.get().strip() or
                self.var_filter_groupe.get().strip()
            )
        
        # Si des filtres sont actifs, utiliser apply_etudiants_filters
        if has_active_filters:
            self.apply_etudiants_filters()
            return
        
        # Sinon, afficher tous les étudiants
        for row in self.tree_etudiants.get_children():
            self.tree_etudiants.delete(row)

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT id, matricule, nom, prenom, COALESCE(email,''), COALESCE(telephone,''), COALESCE(statut,'')
            FROM etudiants
            ORDER BY id DESC
        """)
        rows = cur.fetchall()
        conn.close()

        for r in rows:
            self.tree_etudiants.insert("", "end", values=r)

    def open_fiche_etudiant(self, event=None):
        sel = self.tree_etudiants.selection()
        if not sel:
            return
        values = self.tree_etudiants.item(sel[0], "values")
        etu_id = int(values[0])

        w = tk.Toplevel(self)
        w.title("Fiche étudiant")
        w.geometry("1000x700")
        w.resizable(True, True)

        frm = ttk.Frame(w, padding=10)
        frm.pack(fill="both", expand=True)

        box_id = ttk.LabelFrame(frm, text="Identité & Infos personnelles", padding=10)
        box_id.pack(fill="x")

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT matricule, nom, prenom, COALESCE(email,''), COALESCE(telephone,''), COALESCE(adresse,''),
                   COALESCE(date_naissance,''), COALESCE(lieu_naissance,''), COALESCE(sexe,''), COALESCE(statut,'')
            FROM etudiants WHERE id=?
        """, (etu_id,))
        etu = cur.fetchone()

        ttk.Label(box_id, text=f"Matricule : {etu[0]}").grid(row=0, column=0, sticky="w", padx=6, pady=2)
        ttk.Label(box_id, text=f"Nom : {etu[1]} {etu[2]}").grid(row=0, column=1, sticky="w", padx=6, pady=2)
        ttk.Label(box_id, text=f"Statut : {etu[9]}").grid(row=0, column=2, sticky="w", padx=6, pady=2)
        
        # Calculer et afficher la moyenne et mention
        moyenne, mention, nb_notes = get_student_average(etu_id)
        mention_color = "green" if mention in ["Excellente", "Très bien"] else "orange" if mention in ["Bien", "Assez bien"] else "red"
        ttk.Label(box_id, text=f"Moyenne générale : {moyenne}/20").grid(row=1, column=0, sticky="w", padx=6, pady=2)
        mention_label = ttk.Label(box_id, text=f"Mention : {mention}")
        mention_label.grid(row=1, column=1, sticky="w", padx=6, pady=2)
        ttk.Label(box_id, text=f"Notes : {nb_notes}").grid(row=1, column=2, sticky="w", padx=6, pady=2)
        
        ttk.Label(box_id, text=f"Email : {etu[3]}").grid(row=2, column=0, sticky="w", padx=6, pady=2)
        ttk.Label(box_id, text=f"Téléphone : {etu[4]}").grid(row=2, column=1, sticky="w", padx=6, pady=2)
        ttk.Label(box_id, text=f"Sexe : {etu[8]}").grid(row=2, column=2, sticky="w", padx=6, pady=2)
        
        ttk.Label(box_id, text=f"Adresse : {etu[5][:40]}...").grid(row=3, column=0, columnspan=3, sticky="w", padx=6, pady=2)
        ttk.Label(box_id, text=f"Date naissance : {etu[6]}").grid(row=4, column=0, sticky="w", padx=6, pady=2)
        ttk.Label(box_id, text=f"Pays naissance : {etu[7]}").grid(row=4, column=1, columnspan=2, sticky="w", padx=6, pady=2)

        nb = ttk.Notebook(frm)
        nb.pack(fill="both", expand=True, pady=10)

        t_ins = ttk.Frame(nb)
        t_notes = ttk.Frame(nb)
        t_abs = ttk.Frame(nb)
        nb.add(t_ins, text="Inscriptions")
        nb.add(t_notes, text="Notes")
        nb.add(t_abs, text="Absences")

        tree_i = ttk.Treeview(t_ins, columns=("annee", "filiere", "niveau", "statut"), show="headings")
        for c in ("annee", "filiere", "niveau", "statut"):
            tree_i.heading(c, text=c)
            tree_i.column(c, width=200, anchor="w")
        tree_i.pack(fill="both", expand=True, padx=10, pady=10)

        tree_n = ttk.Treeview(t_notes, columns=("annee", "module", "note", "coef", "type"), show="headings")
        for c in ("annee", "module", "note", "coef", "type"):
            tree_n.heading(c, text=c)
            tree_n.column(c, width=200, anchor="w")
        tree_n.column("note", width=80, anchor="center")
        tree_n.column("coef", width=80, anchor="center")
        tree_n.pack(fill="both", expand=True, padx=10, pady=10)

        tree_a = ttk.Treeview(t_abs, columns=("date", "module", "justifiee", "motif"), show="headings")
        for c in ("date", "module", "justifiee", "motif"):
            tree_a.heading(c, text=c)
            tree_a.column(c, width=220, anchor="w")
        tree_a.pack(fill="both", expand=True, padx=10, pady=10)

        cur.execute("""
            SELECT i.annee_academique,
                   f.code || ' - ' || f.nom,
                   n.code || ' - ' || n.nom,
                   COALESCE(i.statut,'')
            FROM inscriptions i
            JOIN filieres f ON f.id=i.filiere_id
            JOIN niveaux n ON n.id=i.niveau_id
            WHERE i.etudiant_id=?
            ORDER BY i.id DESC
        """, (etu_id,))
        for r in cur.fetchall():
            tree_i.insert("", "end", values=r)

        cur.execute("""
            SELECT COALESCE(no.annee_academique,''),
                   m.code || ' - ' || m.nom,
                   no.note,
                   m.coefficient,
                   COALESCE(no.type_evaluation,'')
            FROM notes no
            JOIN modules m ON m.id=no.module_id
            WHERE no.etudiant_id=?
            ORDER BY no.id DESC
        """, (etu_id,))
        for r in cur.fetchall():
            tree_n.insert("", "end", values=r)

        cur.execute("""
            SELECT a.date_absence,
                   m.code || ' - ' || m.nom,
                   CASE a.justifiee WHEN 1 THEN 'Oui' ELSE 'Non' END,
                   COALESCE(a.motif,'')
            FROM absences a
            JOIN modules m ON m.id=a.module_id
            WHERE a.etudiant_id=?
            ORDER BY a.date_absence DESC
        """, (etu_id,))
        for r in cur.fetchall():
            tree_a.insert("", "end", values=r)

        conn.close()

    def import_etudiants_csv(self):
        path = filedialog.askopenfilename(filetypes=[("CSV", "*.csv")])
        if not path:
            return

        with open(path, "r", encoding="utf-8-sig", newline="") as f:
            reader = csv.DictReader(f)
            rows = list(reader)

        ok = 0
        for row in rows:
            nom = (row.get("nom") or row.get("Nom") or "").strip()
            prenom = (row.get("prenom") or row.get("Prenom") or row.get("Prénom") or "").strip()
            email = (row.get("email") or row.get("Email") or "").strip()
            if not nom or not prenom:
                continue

            matricule = self.generate_matricule(nom, prenom)

            conn = db_connect()
            cur = conn.cursor()
            try:
                cur.execute(
                    "INSERT INTO etudiants (matricule, nom, prenom, email, statut) VALUES (?, ?, ?, ?, ?)",
                    (matricule, nom, prenom, email if email else None, "actif"),
                )
                conn.commit()
                ok += 1
            except sqlite3.IntegrityError:
                pass
            finally:
                conn.close()

        self.refresh_all()
        messagebox.showinfo("OK", f"Import terminé : {ok} étudiant(s).")

    def export_etudiants_csv(self):
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV", "*.csv")])
        if not path:
            return

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT id, matricule, nom, prenom, COALESCE(email,''), COALESCE(statut,'') FROM etudiants ORDER BY id")
        rows = cur.fetchall()
        conn.close()

        with open(path, "w", encoding="utf-8", newline="") as f:
            w = csv.writer(f)
            w.writerow(["id", "matricule", "nom", "prenom", "email", "statut"])
            w.writerows(rows)

        messagebox.showinfo("OK", "Export CSV terminé.")

    def export_etudiants_xlsx(self):
        path = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel", "*.xlsx")])
        if not path:
            return
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT id, matricule, nom, prenom, COALESCE(email,''), COALESCE(statut,'') FROM etudiants ORDER BY id")
        rows = cur.fetchall()
        conn.close()
        export_query_to_xlsx(["id", "matricule", "nom", "prenom", "email", "statut"], rows, path, "etudiants")
        messagebox.showinfo("OK", "Export Excel terminé.")

    def load_filter_options(self):
        """Charger les options des filtres (filières, niveaux, groupes)"""
        conn = db_connect()
        cur = conn.cursor()
        
        # Charger filières
        cur.execute("SELECT code || ' - ' || nom FROM filieres ORDER BY nom")
        filieres = [""] + [row[0] for row in cur.fetchall()]
        self.cb_filter_filiere["values"] = filieres
        
        # Charger niveaux
        cur.execute("SELECT code || ' - ' || nom FROM niveaux ORDER BY ordre")
        niveaux = [""] + [row[0] for row in cur.fetchall()]
        self.cb_filter_niveau["values"] = niveaux
        
        # Charger groupes
        cur.execute("SELECT code || ' - ' || nom FROM groupes ORDER BY nom")
        groupes = [""] + [row[0] for row in cur.fetchall()]
        self.cb_filter_groupe["values"] = groupes
        
        conn.close()

    def apply_etudiants_filters(self):
        """Appliquer les filtres avancés à la liste des étudiants"""
        if not hasattr(self, "tree_etudiants"):
            return
        
        for row in self.tree_etudiants.get_children():
            self.tree_etudiants.delete(row)

        # Récupérer les critères de filtre
        search_text = self.var_search_name.get().strip().lower()
        filiere_text = self.var_filter_filiere.get().strip()
        niveau_text = self.var_filter_niveau.get().strip()
        statut_text = self.var_filter_statut.get().strip()
        groupe_text = self.var_filter_groupe.get().strip()

        conn = db_connect()
        cur = conn.cursor()

        # Construire la requête SQL avec les filtres
        query = """
            SELECT DISTINCT e.id, e.matricule, e.nom, e.prenom, COALESCE(e.email,''), COALESCE(e.telephone,''), COALESCE(e.statut,'')
            FROM etudiants e
            LEFT JOIN inscriptions i ON e.id = i.etudiant_id
            LEFT JOIN filieres f ON i.filiere_id = f.id
            LEFT JOIN niveaux n ON i.niveau_id = n.id
            LEFT JOIN groupes g ON i.groupe_id = g.id
            WHERE 1=1
        """
        params = []

        # Ajouter les conditions de filtre
        if search_text:
            query += " AND (LOWER(e.nom) LIKE ? OR LOWER(e.prenom) LIKE ? OR LOWER(e.email) LIKE ? OR e.matricule LIKE ?)"
            search_param = f"%{search_text}%"
            params.extend([search_param, search_param, search_param, search_param])

        if filiere_text:
            filiere_code = filiere_text.split(" - ")[0]
            query += " AND f.code = ?"
            params.append(filiere_code)

        if niveau_text:
            niveau_code = niveau_text.split(" - ")[0]
            query += " AND n.code = ?"
            params.append(niveau_code)

        if statut_text:
            query += " AND e.statut = ?"
            params.append(statut_text)

        if groupe_text:
            groupe_code = groupe_text.split(" - ")[0]
            query += " AND g.code = ?"
            params.append(groupe_code)

        query += " ORDER BY e.id DESC"

        cur.execute(query, params)
        rows = cur.fetchall()
        conn.close()

        for r in rows:
            self.tree_etudiants.insert("", "end", values=r)

    def reset_etudiants_filters(self):
        """Réinitialiser tous les filtres"""
        self.var_search_name.set("")
        self.var_filter_filiere.set("")
        self.var_filter_niveau.set("")
        self.var_filter_statut.set("")
        self.var_filter_groupe.set("")
        self.refresh_etudiants_list()

    # ACADEMIQUE

    def build_academique_tab(self):
        frm = ttk.Frame(self.tab_academique, padding=10)
        frm.pack(fill="both", expand=True)

        lf = ttk.LabelFrame(frm, text="Filières", padding=10)
        ln = ttk.LabelFrame(frm, text="Niveaux", padding=10)
        lg = ttk.LabelFrame(frm, text="Groupes", padding=10)
        ls = ttk.LabelFrame(frm, text="Spécialités", padding=10)
        lf.pack(side="left", fill="both", expand=True, padx=(0, 10))
        ln.pack(side="left", fill="both", expand=True, padx=(0, 10))
        lg.pack(side="left", fill="both", expand=True, padx=(0, 10))
        ls.pack(side="left", fill="both", expand=True)

        ttk.Label(lf, text="Code").grid(row=0, column=0, sticky="w", pady=4)
        ttk.Label(lf, text="Nom").grid(row=1, column=0, sticky="w", pady=4)
        self.f_code = ttk.Entry(lf, width=22)
        self.f_nom = ttk.Entry(lf, width=22)
        self.f_code.grid(row=0, column=1, pady=4)
        self.f_nom.grid(row=1, column=1, pady=4)
        ttk.Button(lf, text="Ajouter filière", command=self.add_filiere).grid(row=2, column=1, sticky="e", pady=(10, 0))

        self.list_filieres = tk.Listbox(lf, height=16, width=45)
        self.list_filieres.grid(row=3, column=0, columnspan=2, pady=(12, 0), sticky="nsew")
        
        # Buttons for filières
        btn_f = ttk.Frame(lf)
        btn_f.grid(row=4, column=0, columnspan=2, sticky="ew", pady=(8, 0))
        ttk.Button(btn_f, text="Modifier", command=self.edit_filiere).pack(side="left", padx=2)
        ttk.Button(btn_f, text="Supprimer", command=self.delete_filiere).pack(side="left", padx=2)

        ttk.Label(ln, text="Code").grid(row=0, column=0, sticky="w", pady=4)
        ttk.Label(ln, text="Nom").grid(row=1, column=0, sticky="w", pady=4)
        ttk.Label(ln, text="Ordre").grid(row=2, column=0, sticky="w", pady=4)
        self.n_code = ttk.Entry(ln, width=22)
        self.n_nom = ttk.Entry(ln, width=22)
        self.n_ordre = ttk.Entry(ln, width=22)
        self.n_code.grid(row=0, column=1, pady=4)
        self.n_nom.grid(row=1, column=1, pady=4)
        self.n_ordre.grid(row=2, column=1, pady=4)
        ttk.Button(ln, text="Ajouter niveau", command=self.add_niveau).grid(row=3, column=1, sticky="e", pady=(10, 0))

        self.list_niveaux = tk.Listbox(ln, height=16, width=45)
        self.list_niveaux.grid(row=4, column=0, columnspan=2, pady=(12, 0), sticky="nsew")
        
        # Buttons for niveaux
        btn_n = ttk.Frame(ln)
        btn_n.grid(row=5, column=0, columnspan=2, sticky="ew", pady=(8, 0))
        ttk.Button(btn_n, text="Modifier", command=self.edit_niveau).pack(side="left", padx=2)
        ttk.Button(btn_n, text="Supprimer", command=self.delete_niveau).pack(side="left", padx=2)

        # GROUPES
        ttk.Label(lg, text="Code").grid(row=0, column=0, sticky="w", pady=4)
        ttk.Label(lg, text="Nom").grid(row=1, column=0, sticky="w", pady=4)
        self.g_code = ttk.Entry(lg, width=22)
        self.g_nom = ttk.Entry(lg, width=22)
        self.g_code.grid(row=0, column=1, pady=4)
        self.g_nom.grid(row=1, column=1, pady=4)
        ttk.Button(lg, text="Ajouter groupe", command=self.add_groupe).grid(row=2, column=1, sticky="e", pady=(10, 0))

        self.list_groupes = tk.Listbox(lg, height=16, width=45)
        self.list_groupes.grid(row=3, column=0, columnspan=2, pady=(12, 0), sticky="nsew")
        
        # Buttons for groupes
        btn_g = ttk.Frame(lg)
        btn_g.grid(row=4, column=0, columnspan=2, sticky="ew", pady=(8, 0))
        ttk.Button(btn_g, text="Modifier", command=self.edit_groupe).pack(side="left", padx=2)
        ttk.Button(btn_g, text="Supprimer", command=self.delete_groupe).pack(side="left", padx=2)

        # SPÉCIALITÉS
        ttk.Label(ls, text="Filière").grid(row=0, column=0, sticky="w", pady=4)
        self.var_spec_filiere = tk.StringVar()
        self.cb_spec_filiere = ttk.Combobox(ls, textvariable=self.var_spec_filiere, width=25, state="readonly")
        self.cb_spec_filiere.grid(row=0, column=1, pady=4)
        self.cb_spec_filiere.bind("<<ComboboxSelected>>", lambda e: self.refresh_specialites_list())

        ttk.Label(ls, text="Nom").grid(row=1, column=0, sticky="w", pady=4)
        ttk.Label(ls, text="Description").grid(row=2, column=0, sticky="w", pady=4)
        self.s_nom = ttk.Entry(ls, width=25)
        self.s_description = ttk.Entry(ls, width=25)
        self.s_nom.grid(row=1, column=1, pady=4)
        self.s_description.grid(row=2, column=1, pady=4)

        ttk.Button(ls, text="Ajouter spécialité", command=self.add_specialite).grid(row=3, column=1, sticky="e", pady=(10, 0))

        self.list_specialites = tk.Listbox(ls, height=12, width=50)
        self.list_specialites.grid(row=4, column=0, columnspan=2, pady=(12, 0), sticky="nsew")

        # Boutons pour gérer spécialités
        ttk.Button(ls, text="Supprimer", command=self.delete_specialite).grid(row=5, column=0, columnspan=2, sticky="ew", pady=(4, 0))

    def add_filiere(self):
        code = self.f_code.get().strip()
        nom = self.f_nom.get().strip()
        if not code or not nom:
            messagebox.showerror("Erreur", "Code et nom filière obligatoires.")
            return

        conn = db_connect()
        cur = conn.cursor()
        
        try:
            # Check if editing or adding
            if hasattr(self, 'current_edit_filiere_id'):
                cur.execute("UPDATE filieres SET code=?, nom=? WHERE id=?", 
                           (code, nom, self.current_edit_filiere_id))
                conn.commit()
                messagebox.showinfo("OK", "Filière modifiée.")
                delattr(self, 'current_edit_filiere_id')
            else:
                cur.execute("INSERT INTO filieres (code, nom) VALUES (?, ?)", (code, nom))
                conn.commit()
                messagebox.showinfo("OK", "Filière ajoutée.")
        except sqlite3.IntegrityError:
            messagebox.showerror("Erreur", "Code filière déjà utilisé.")
        finally:
            conn.close()

        self.f_code.delete(0, tk.END)
        self.f_nom.delete(0, tk.END)
        self.refresh_all()

    def add_niveau(self):
        code = self.n_code.get().strip()
        nom = self.n_nom.get().strip()
        ordre_txt = self.n_ordre.get().strip()

        if not code or not nom:
            messagebox.showerror("Erreur", "Code et nom niveau obligatoires.")
            return

        ordre = None
        if ordre_txt:
            if not ordre_txt.isdigit():
                messagebox.showerror("Erreur", "Ordre doit être un entier (ex: 4).")
                return
            ordre = int(ordre_txt)

        conn = db_connect()
        cur = conn.cursor()
        
        try:
            # Check if editing or adding
            if hasattr(self, 'current_edit_niveau_id'):
                cur.execute("UPDATE niveaux SET code=?, nom=?, ordre=? WHERE id=?", 
                           (code, nom, ordre, self.current_edit_niveau_id))
                conn.commit()
                messagebox.showinfo("OK", "Niveau modifié.")
                delattr(self, 'current_edit_niveau_id')
            else:
                cur.execute("INSERT INTO niveaux (code, nom, ordre) VALUES (?, ?, ?)", (code, nom, ordre))
                conn.commit()
                messagebox.showinfo("OK", "Niveau ajouté.")
        except sqlite3.IntegrityError:
            messagebox.showerror("Erreur", "Code niveau déjà utilisé.")
        finally:
            conn.close()

        self.n_code.delete(0, tk.END)
        self.n_nom.delete(0, tk.END)
        self.n_ordre.delete(0, tk.END)
        self.refresh_all()

    def edit_filiere(self):
        selection = self.list_filieres.curselection()
        if not selection:
            messagebox.showerror("Erreur", "Sélectionnez une filière à modifier.")
            return
        
        fid = int(self.list_filieres.get(selection[0]).split(" - ")[0])
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT code, nom FROM filieres WHERE id=?", (fid,))
        row = cur.fetchone()
        conn.close()
        
        if row:
            self.f_code.delete(0, tk.END)
            self.f_code.insert(0, row[0])
            self.f_nom.delete(0, tk.END)
            self.f_nom.insert(0, row[1])
            self.current_edit_filiere_id = fid

    def delete_filiere(self):
        selection = self.list_filieres.curselection()
        if not selection:
            messagebox.showerror("Erreur", "Sélectionnez une filière à supprimer.")
            return
        
        if not messagebox.askyesno("Confirmation", "Supprimer cette filière ?"):
            return
        
        fid = int(self.list_filieres.get(selection[0]).split(" - ")[0])
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("DELETE FROM filieres WHERE id=?", (fid,))
        conn.commit()
        conn.close()
        self.refresh_all()

    def edit_niveau(self):
        selection = self.list_niveaux.curselection()
        if not selection:
            messagebox.showerror("Erreur", "Sélectionnez un niveau à modifier.")
            return
        
        nid = int(self.list_niveaux.get(selection[0]).split(" - ")[0])
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT code, nom, COALESCE(ordre,'') FROM niveaux WHERE id=?", (nid,))
        row = cur.fetchone()
        conn.close()
        
        if row:
            self.n_code.delete(0, tk.END)
            self.n_code.insert(0, row[0])
            self.n_nom.delete(0, tk.END)
            self.n_nom.insert(0, row[1])
            self.n_ordre.delete(0, tk.END)
            self.n_ordre.insert(0, str(row[2]))
            self.current_edit_niveau_id = nid

    def delete_niveau(self):
        selection = self.list_niveaux.curselection()
        if not selection:
            messagebox.showerror("Erreur", "Sélectionnez un niveau à supprimer.")
            return
        
        if not messagebox.askyesno("Confirmation", "Supprimer ce niveau ?"):
            return
        
        nid = int(self.list_niveaux.get(selection[0]).split(" - ")[0])
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("DELETE FROM niveaux WHERE id=?", (nid,))
        conn.commit()
        conn.close()
        self.refresh_all()

    def add_groupe(self):
        code = self.g_code.get().strip()
        nom = self.g_nom.get().strip()
        if not code or not nom:
            messagebox.showerror("Erreur", "Code et nom groupe obligatoires.")
            return

        conn = db_connect()
        cur = conn.cursor()
        
        try:
            # Check if editing or adding
            if hasattr(self, 'current_edit_groupe_id'):
                cur.execute("UPDATE groupes SET code=?, nom=? WHERE id=?", 
                           (code, nom, self.current_edit_groupe_id))
                conn.commit()
                messagebox.showinfo("OK", "Groupe modifié.")
                delattr(self, 'current_edit_groupe_id')
            else:
                cur.execute("INSERT INTO groupes (code, nom) VALUES (?, ?)", (code, nom))
                conn.commit()
                messagebox.showinfo("OK", "Groupe ajouté.")
        except sqlite3.IntegrityError:
            messagebox.showerror("Erreur", "Code groupe déjà utilisé.")
        finally:
            conn.close()

        self.g_code.delete(0, tk.END)
        self.g_nom.delete(0, tk.END)
        self.refresh_all()

    def edit_groupe(self):
        selection = self.list_groupes.curselection()
        if not selection:
            messagebox.showerror("Erreur", "Sélectionnez un groupe à modifier.")
            return
        
        gid = int(self.list_groupes.get(selection[0]).split(" - ")[0])
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT code, nom FROM groupes WHERE id=?", (gid,))
        row = cur.fetchone()
        conn.close()
        
        if row:
            self.g_code.delete(0, tk.END)
            self.g_code.insert(0, row[0])
            self.g_nom.delete(0, tk.END)
            self.g_nom.insert(0, row[1])
            self.current_edit_groupe_id = gid

    def delete_groupe(self):
        selection = self.list_groupes.curselection()
        if not selection:
            messagebox.showerror("Erreur", "Sélectionnez un groupe à supprimer.")
            return
        
        if not messagebox.askyesno("Confirmation", "Supprimer ce groupe ?"):
            return
        
        gid = int(self.list_groupes.get(selection[0]).split(" - ")[0])
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("DELETE FROM groupes WHERE id=?", (gid,))
        conn.commit()
        conn.close()
        self.refresh_all()

    def refresh_filieres(self):
        if not hasattr(self, "list_filieres"):
            return
        self.list_filieres.delete(0, tk.END)
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT id, code, nom FROM filieres ORDER BY code")
        self._filieres = cur.fetchall()
        conn.close()

        for (fid, code, nom) in self._filieres:
            self.list_filieres.insert(tk.END, f"{fid} - {code} - {nom}")

        fil_values = [f"{fid} - {code} - {nom}" for (fid, code, nom) in self._filieres]
        if hasattr(self, "cb_filiere"): self.cb_filiere["values"] = fil_values
        if hasattr(self, "cb_mod_filiere"): self.cb_mod_filiere["values"] = fil_values
        if hasattr(self, "refresh_specialites_combobox"): self.refresh_specialites_combobox()

    def refresh_niveaux(self):
        if not hasattr(self, "list_niveaux"):
            return
        self.list_niveaux.delete(0, tk.END)
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT id, code, nom, COALESCE(ordre,'') FROM niveaux ORDER BY COALESCE(ordre, 999), code")
        self._niveaux = cur.fetchall()
        conn.close()

        for (nid, code, nom, ordre) in self._niveaux:
            self.list_niveaux.insert(tk.END, f"{nid} - {code} - {nom} - ordre:{ordre}")

        niv_values = [f"{nid} - {code} - {nom}" for (nid, code, nom, _) in self._niveaux]
        if hasattr(self, "cb_niveau"): self.cb_niveau["values"] = niv_values
        if hasattr(self, "cb_mod_niveau"): self.cb_mod_niveau["values"] = niv_values

    def refresh_groupes(self):
        if not hasattr(self, "list_groupes"):
            return
        self.list_groupes.delete(0, tk.END)
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT id, code, nom FROM groupes ORDER BY code")
        self._groupes = cur.fetchall()
        conn.close()

        for (gid, code, nom) in self._groupes:
            self.list_groupes.insert(tk.END, f"{gid} - {code} - {nom}")

        grp_values = [f"{gid} - {code} - {nom}" for (gid, code, nom) in self._groupes]
        if hasattr(self, "cb_groupe"): self.cb_groupe["values"] = grp_values
        if hasattr(self, "cb_filter_groupe"): self.cb_filter_groupe["values"] = grp_values

    def populate_semestres(self):
        """Charger les semestres disponibles dans le ComboBox"""
        if not hasattr(self, "cb_mod_semestre"):
            return
        
        conn = db_connect()
        cur = conn.cursor()
        
        # Get unique semestres from existing modules
        cur.execute("SELECT DISTINCT semestre FROM modules WHERE semestre IS NOT NULL ORDER BY semestre")
        existing_semestres = [row[0] for row in cur.fetchall()]
        
        # Also get semestres from niveaux codes (assuming niveaux.code is like 'S07', 'S08', etc.)
        cur.execute("SELECT DISTINCT code FROM niveaux WHERE code LIKE 'S%' ORDER BY code")
        niveau_semestres = [row[0] for row in cur.fetchall()]
        
        conn.close()
        
        # Combine and deduplicate
        all_semestres = sorted(set(existing_semestres + niveau_semestres))
        
        # Default common semesters if none found (S01-S10)
        if not all_semestres:
            all_semestres = [f"S{i:02d}" for i in range(1, 11)]
        else:
            # Ajouter les semestres manquants de S01 à S10
            default_semesters = [f"S{i:02d}" for i in range(1, 11)]
            all_semestres = sorted(set(all_semestres + default_semesters))
        
        self.cb_mod_semestre["values"] = all_semestres

    def refresh_specialites_combobox(self):
        """Charger les filières dans le ComboBox des spécialités"""
        if not hasattr(self, "cb_spec_filiere"):
            return
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT id, code, nom FROM filieres ORDER BY code")
        self._spec_filieres = cur.fetchall()
        conn.close()
        
        spec_fil_values = [f"{fid} - {code} - {nom}" for (fid, code, nom) in self._spec_filieres]
        self.cb_spec_filiere["values"] = spec_fil_values

    def add_specialite(self):
        """Ajouter une nouvelle spécialité"""
        filiere_text = self.var_spec_filiere.get().strip()
        nom = self.s_nom.get().strip()
        description = self.s_description.get().strip()

        if not filiere_text or not nom:
            messagebox.showerror("Erreur", "Filière et nom spécialité obligatoires.")
            return

        try:
            filiere_id = int(filiere_text.split(" - ")[0])
        except (ValueError, IndexError):
            messagebox.showerror("Erreur", "Sélectionnez une filière valide.")
            return

        conn = db_connect()
        cur = conn.cursor()
        try:
            cur.execute(
                "INSERT INTO specialites (filiere_id, nom, description) VALUES (?, ?, ?)",
                (filiere_id, nom, description if description else None)
            )
            conn.commit()
            messagebox.showinfo("OK", "Spécialité ajoutée.")
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de l'ajout: {str(e)}")
        finally:
            conn.close()

        self.s_nom.delete(0, tk.END)
        self.s_description.delete(0, tk.END)
        self.refresh_specialites_list()
        self.refresh_all()

    def refresh_specialites_list(self):
        """Rafraîchir la liste des spécialités selon la filière sélectionnée"""
        if not hasattr(self, "list_specialites"):
            return
        
        self.list_specialites.delete(0, tk.END)
        
        filiere_text = self.var_spec_filiere.get().strip()
        if not filiere_text:
            return

        try:
            filiere_id = int(filiere_text.split(" - ")[0])
        except (ValueError, IndexError):
            return

        conn = db_connect()
        cur = conn.cursor()
        cur.execute(
            "SELECT id, nom, COALESCE(description,'') FROM specialites WHERE filiere_id=? ORDER BY nom",
            (filiere_id,)
        )
        self._specialites = cur.fetchall()
        conn.close()

        for (sid, nom, description) in self._specialites:
            display = f"{sid} - {nom}"
            if description:
                display += f" ({description[:20]}...)" if len(description) > 20 else f" ({description})"
            self.list_specialites.insert(tk.END, display)

    def delete_specialite(self):
        """Supprimer la spécialité sélectionnée"""
        sel_idx = self.list_specialites.curselection()
        if not sel_idx:
            messagebox.showerror("Erreur", "Sélectionnez une spécialité à supprimer.")
            return

        spec_id = self._specialites[sel_idx[0]][0]
        
        if not messagebox.askyesno("Confirmation", "Supprimer cette spécialité ?"):
            return

        conn = db_connect()
        cur = conn.cursor()
        try:
            cur.execute("DELETE FROM specialites WHERE id=?", (spec_id,))
            conn.commit()
            messagebox.showinfo("OK", "Spécialité supprimée.")
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de la suppression: {str(e)}")
        finally:
            conn.close()

        self.refresh_specialites_list()

    # INSCRIPTIONS

    def build_inscriptions_tab(self):
        frm = ttk.Frame(self.tab_inscriptions, padding=10)
        frm.pack(fill="both", expand=True)

        top = ttk.LabelFrame(frm, text="Nouvelle inscription", padding=10)
        top.pack(fill="x")

        ttk.Label(top, text="Étudiant").grid(row=0, column=0, sticky="w", pady=4)
        ttk.Label(top, text="Filière").grid(row=1, column=0, sticky="w", pady=4)
        ttk.Label(top, text="Niveau").grid(row=2, column=0, sticky="w", pady=4)
        ttk.Label(top, text="Groupe").grid(row=3, column=0, sticky="w", pady=4)
        ttk.Label(top, text="Année académique").grid(row=4, column=0, sticky="w", pady=4)

        self.cb_etudiant = ttk.Combobox(top, width=70, state="readonly")
        self.cb_filiere = ttk.Combobox(top, width=70, state="readonly")
        self.cb_niveau = ttk.Combobox(top, width=70, state="readonly")
        self.cb_groupe = ttk.Combobox(top, values=[], width=68, state="readonly")
        self.cb_annee = YearCombobox(top, width=20, state="readonly")

        self.cb_etudiant.grid(row=0, column=1, padx=6, pady=4, sticky="w")
        self.cb_filiere.grid(row=1, column=1, padx=6, pady=4, sticky="w")
        self.cb_niveau.grid(row=2, column=1, padx=6, pady=4, sticky="w")
        self.cb_groupe.grid(row=3, column=1, padx=6, pady=4, sticky="w")
        self.cb_annee.grid(row=4, column=1, padx=6, pady=4, sticky="w")

        self.btn_ins_action = ttk.Button(top, text="Enregistrer inscription", command=self.add_inscription)
        self.btn_ins_action.grid(row=5, column=1, sticky="e", pady=(10, 0))

        bottom = ttk.LabelFrame(frm, text="Historique des inscriptions", padding=10)
        bottom.pack(fill="both", expand=True, pady=(10, 0))

        cols = ("id", "matricule", "etudiant", "filiere", "niveau", "groupe", "annee", "statut")
        self.tree_inscriptions = ttk.Treeview(bottom, columns=cols, show="headings")
        for c in cols:
            self.tree_inscriptions.heading(c, text=c)
            self.tree_inscriptions.column(c, width=120, anchor="w")
        self.tree_inscriptions.column("id", width=40, anchor="center")
        self.tree_inscriptions.column("annee", width=90, anchor="center")
        self.tree_inscriptions.column("groupe", width=80, anchor="center")

        self.tree_inscriptions.pack(fill="both", expand=True)
        self.tree_inscriptions.bind("<Double-1>", self.load_inscription_to_edit)
        
        # Buttons
        btn_frame = ttk.Frame(bottom)
        btn_frame.pack(fill="x", pady=(8, 0))
        ttk.Button(btn_frame, text="Modifier inscription", command=self.load_inscription_to_edit).pack(side="left", padx=4)
        ttk.Button(btn_frame, text="Supprimer inscription", command=self.delete_inscription).pack(side="left", padx=4)

    def refresh_inscriptions_lists(self):
        if not hasattr(self, "cb_etudiant"):
            return

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT id, matricule, nom, prenom FROM etudiants ORDER BY nom, prenom")
        self._etudiants = cur.fetchall()
        
        # Load groupes
        cur.execute("SELECT id, nom FROM groupes ORDER BY nom")
        self._groupes = cur.fetchall()
        conn.close()

        vals_etu = [f"{eid} - {mat} - {nom} {prenom}" for (eid, mat, nom, prenom) in self._etudiants]
        self.cb_etudiant["values"] = vals_etu
        if hasattr(self, "cb_note_etudiant"): self.cb_note_etudiant["values"] = vals_etu
        if hasattr(self, "cb_abs_etudiant"): self.cb_abs_etudiant["values"] = vals_etu
        if hasattr(self, "cb_doc_etudiant"): self.cb_doc_etudiant["values"] = vals_etu
        
        # Load groupes
        vals_groupe = [f"{gid} - {gnom}" for (gid, gnom) in self._groupes]
        if hasattr(self, "cb_groupe"): self.cb_groupe["values"] = vals_groupe

        if hasattr(self, "tree_inscriptions"):
            for row in self.tree_inscriptions.get_children():
                self.tree_inscriptions.delete(row)

            conn = db_connect()
            cur = conn.cursor()
            cur.execute("""
                SELECT i.id,
                       e.matricule,
                       e.nom || ' ' || e.prenom AS etu,
                       f.code || ' - ' || f.nom AS fil,
                       n.code || ' - ' || n.nom AS niv,
                       COALESCE(i.groupe_id, '') AS groupe,
                       i.annee_academique,
                       COALESCE(i.statut,'')
                FROM inscriptions i
                JOIN etudiants e ON e.id = i.etudiant_id
                JOIN filieres f  ON f.id = i.filiere_id
                JOIN niveaux n   ON n.id = i.niveau_id
                ORDER BY i.id DESC
            """)
            rows = cur.fetchall()
            conn.close()

            for r in rows:
                self.tree_inscriptions.insert("", "end", values=r)

    def add_inscription(self):
        etu_id = self.parse_id_from_combo(self.cb_etudiant.get())
        filiere_id = self.parse_id_from_combo(self.cb_filiere.get())
        niveau_id = self.parse_id_from_combo(self.cb_niveau.get())
        groupe_text = self.cb_groupe.get().strip()
        annee = self.cb_annee.get().strip()

        if not (etu_id and filiere_id and niveau_id and annee):
            messagebox.showerror("Erreur", "Étudiant, filière, niveau et année sont obligatoires.")
            return

        # Parse groupe_id from text (e.g., "5 - Groupe 1" -> 5)
        groupe_id = None
        if groupe_text:
            try:
                groupe_id = int(groupe_text.split("-", 1)[0].strip())
            except (ValueError, IndexError):
                groupe_id = None

        conn = db_connect()
        cur = conn.cursor()
        
        try:
            # Check if editing or adding
            if hasattr(self, 'current_edit_inscription_id'):
                cur.execute("""
                    UPDATE inscriptions SET etudiant_id=?, filiere_id=?, niveau_id=?, 
                                          groupe_id=?, annee_academique=?
                    WHERE id=?
                """, (etu_id, filiere_id, niveau_id, groupe_id, annee, self.current_edit_inscription_id))
                conn.commit()
                messagebox.showinfo("OK", "Inscription modifiée.")
                delattr(self, 'current_edit_inscription_id')
            else:
                cur.execute("""
                    INSERT INTO inscriptions (etudiant_id, filiere_id, niveau_id, groupe_id, annee_academique, statut)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (etu_id, filiere_id, niveau_id, groupe_id, annee, "inscrit"))
                conn.commit()
                messagebox.showinfo("OK", "Inscription enregistrée.")
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur: {str(e)}")
        finally:
            conn.close()

        self.cb_etudiant.set("")
        self.cb_filiere.set("")
        self.cb_niveau.set("")
        self.cb_groupe.set("")
        self.cb_annee.set(str(datetime.now().year))
        self.refresh_inscriptions_lists()

    def load_inscription_to_edit(self, event=None):
        sel = self.tree_inscriptions.selection()
        if not sel:
            messagebox.showerror("Erreur", "Sélectionnez une inscription à modifier.")
            return
        
        values = self.tree_inscriptions.item(sel[0], 'values')
        ins_id = int(values[0])
        
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT etudiant_id, filiere_id, niveau_id, COALESCE(groupe_id,''), annee_academique
            FROM inscriptions WHERE id=?
        """, (ins_id,))
        row = cur.fetchone()
        conn.close()
        
        if row:
            etu_id, fil_id, niv_id, groupe, annee = row
            
            # Set comboboxes
            for v in self.cb_etudiant['values']:
                if v.startswith(f"{etu_id} -"):
                    self.cb_etudiant.set(v)
                    break
            for v in self.cb_filiere['values']:
                if v.startswith(f"{fil_id} -"):
                    self.cb_filiere.set(v)
                    break
            for v in self.cb_niveau['values']:
                if v.startswith(f"{niv_id} -"):
                    self.cb_niveau.set(v)
                    break
            
            if groupe:
                self.cb_groupe.set(groupe)
            
            self.e_annee.delete(0, tk.END)
            self.e_annee.insert(0, annee)
            
            self.current_edit_inscription_id = ins_id
            self.current_edit_inscription_id = ins_id
            self.btn_ins_action.config(text="Valider la modification")

    def delete_inscription(self):
        sel = self.tree_inscriptions.selection()
        if not sel:
            messagebox.showerror("Erreur", "Sélectionnez une inscription à supprimer.")
            return
        
        if not messagebox.askyesno("Confirmation", "Supprimer cette inscription ?"):
            return
        
        values = self.tree_inscriptions.item(sel[0], 'values')
        ins_id = int(values[0])
        
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("DELETE FROM inscriptions WHERE id=?", (ins_id,))
        conn.commit()
        conn.close()
        
        self.refresh_inscriptions_lists()

    # MODULES & NOTES

    def build_notes_tab(self):
        frm = ttk.Frame(self.tab_notes, padding=10)
        frm.pack(fill="both", expand=True)

        # LEFT PANEL: Modules with two-step creation
        left = ttk.LabelFrame(frm, text="Gestion des Modules", padding=10)
        left.pack(side="left", fill="both", expand=False, padx=(0, 10))

        # ÉTAPE 1: Créer le module de base
        step1_frame = ttk.LabelFrame(left, text="Étape 1: Créer le module", padding=8)
        step1_frame.pack(fill="x", pady=(0, 10))

        ttk.Label(step1_frame, text="Code *").grid(row=0, column=0, sticky="w", pady=3)
        ttk.Label(step1_frame, text="Nom *").grid(row=1, column=0, sticky="w", pady=3)
        ttk.Label(step1_frame, text="Coefficient *").grid(row=2, column=0, sticky="w", pady=3)
        ttk.Label(step1_frame, text="Crédits").grid(row=3, column=0, sticky="w", pady=3)
        ttk.Label(step1_frame, text="Semestre").grid(row=4, column=0, sticky="w", pady=3)

        self.e_mod_code = ttk.Entry(step1_frame, width=24)
        self.e_mod_nom = ttk.Entry(step1_frame, width=24)
        self.e_mod_coef = ttk.Entry(step1_frame, width=24)
        self.e_mod_credits = ttk.Entry(step1_frame, width=24)
        self.cb_mod_semestre = ttk.Combobox(step1_frame, width=22, state="readonly")

        self.e_mod_code.grid(row=0, column=1, pady=3, sticky="w")
        self.e_mod_nom.grid(row=1, column=1, pady=3, sticky="w")
        self.e_mod_coef.grid(row=2, column=1, pady=3, sticky="w")
        self.e_mod_credits.grid(row=3, column=1, pady=3, sticky="w")
        self.cb_mod_semestre.grid(row=4, column=1, pady=3, sticky="w")

        ttk.Label(step1_frame, text="Ex: 2.5", font=("", 8)).grid(row=2, column=2, sticky="w", padx=4)
        ttk.Label(step1_frame, text="S07, S08, S09...", font=("", 8)).grid(row=4, column=2, sticky="w", padx=4)

        ttk.Button(step1_frame, text="Créer le module", command=self.add_module).grid(row=5, column=1, sticky="e", pady=(8, 0))

        # ÉTAPE 2: Associer à Filière/Niveau (optionnel)
        step2_frame = ttk.LabelFrame(left, text="Étape 2: Associer à Filière/Niveau (optionnel)", padding=8)
        step2_frame.pack(fill="x", pady=(0, 10))

        ttk.Label(step2_frame, text="Module *").grid(row=0, column=0, sticky="w", pady=3)
        ttk.Label(step2_frame, text="Filière").grid(row=1, column=0, sticky="w", pady=3)
        ttk.Label(step2_frame, text="Niveau").grid(row=2, column=0, sticky="w", pady=3)

        self.cb_mod_select = ttk.Combobox(step2_frame, width=40, state="readonly")
        self.cb_mod_filiere = ttk.Combobox(step2_frame, width=40, state="readonly")
        self.cb_mod_niveau = ttk.Combobox(step2_frame, width=40, state="readonly")

        self.cb_mod_select.grid(row=0, column=1, pady=3, sticky="w")
        self.cb_mod_filiere.grid(row=1, column=1, pady=3, sticky="w")
        self.cb_mod_niveau.grid(row=2, column=1, pady=3, sticky="w")

        ttk.Button(step2_frame, text="Associer", command=self.associate_module).grid(row=3, column=1, sticky="e", pady=(8, 0))

        # Liste des modules
        list_frame = ttk.LabelFrame(left, text="Modules existants", padding=8)
        list_frame.pack(fill="both", expand=True, pady=(0, 0))

        self.list_modules = tk.Listbox(list_frame, height=14, width=62)
        self.list_modules.pack(fill="both", expand=True)

        # RIGHT PANEL: Notes
        right = ttk.LabelFrame(frm, text="Gestion des Notes", padding=10)
        right.pack(side="left", fill="both", expand=True)

        top = ttk.Frame(right)
        top.pack(fill="x")

        ttk.Label(top, text="Étudiant").grid(row=0, column=0, sticky="w", pady=3)
        ttk.Label(top, text="Module").grid(row=1, column=0, sticky="w", pady=3)
        ttk.Label(top, text="Note (0-20)").grid(row=2, column=0, sticky="w", pady=3)
        ttk.Label(top, text="Type").grid(row=3, column=0, sticky="w", pady=3)
        ttk.Label(top, text="Année").grid(row=4, column=0, sticky="w", pady=3)

        self.cb_note_etudiant = ttk.Combobox(top, width=60, state="readonly")
        self.cb_note_module = ttk.Combobox(top, width=60, state="readonly")
        self.e_note = ttk.Entry(top, width=18)
        
        # MODIFICATION : Liste des types d'évaluation
        types_eval = ["CC - Contrôle Continu", "CT - Contrôle Terminal", "DS - Devoir Surveillé", "TP - Travaux Pratiques", "PROJET - Projet", "Rattrapage"]
        self.cb_note_type = ttk.Combobox(top, values=types_eval, width=25, state="readonly")
        
        # MODIFICATION : Liste des années (dynamique)
        curr_year = datetime.now().year
        annees = [str(y) for y in range(curr_year + 1, curr_year - 50, -1)]
        self.cb_note_annee = ttk.Combobox(top, values=annees, width=18)
        self.cb_note_annee.set(str(curr_year))

        self.cb_note_etudiant.grid(row=0, column=1, padx=6, pady=3, sticky="w")
        self.cb_note_module.grid(row=1, column=1, padx=6, pady=3, sticky="w")
        self.e_note.grid(row=2, column=1, padx=6, pady=3, sticky="w")
        self.cb_note_type.grid(row=3, column=1, padx=6, pady=3, sticky="w")
        self.cb_note_annee.grid(row=4, column=1, padx=6, pady=3, sticky="w")

        btns = ttk.Frame(top)
        btns.grid(row=5, column=0, columnspan=2, sticky="ew", pady=(8, 0))
        ttk.Button(btns, text="Calculer moyenne", command=self.compute_moyenne).pack(side="left")
        ttk.Button(btns, text="Enregistrer note", command=self.add_note).pack(side="right", padx=6)
        ttk.Button(btns, text="Modifier note", command=self.update_note_selected).pack(side="right", padx=6)
        ttk.Button(btns, text="Supprimer note", command=self.delete_note_selected).pack(side="right", padx=6)

        self.lbl_moyenne = ttk.Label(top, text="Moyenne: -")
        self.lbl_moyenne.grid(row=6, column=0, columnspan=2, sticky="w", pady=(8, 0))

        bottom = ttk.Frame(right)
        bottom.pack(fill="both", expand=True, pady=(10, 0))

        cols = ("id", "etudiant", "module", "note", "coef", "annee", "type")
        self.tree_notes = ttk.Treeview(bottom, columns=cols, show="headings")
        for c in cols:
            self.tree_notes.heading(c, text=c)
            self.tree_notes.column(c, width=150, anchor="w")
        self.tree_notes.column("id", width=60, anchor="center")
        self.tree_notes.column("note", width=80, anchor="center")
        self.tree_notes.column("coef", width=70, anchor="center")
        self.tree_notes.pack(fill="both", expand=True)

        audit_box = ttk.LabelFrame(right, text="Traçabilité (notes_audit)", padding=10)
        audit_box.pack(fill="both", expand=False, pady=(8, 0))
        self.tree_audit = ttk.Treeview(audit_box, columns=("id", "action", "old", "new", "at", "by"), show="headings")
        for c, w in [("id", 60), ("action", 80), ("old", 240), ("new", 240), ("at", 160), ("by", 120)]:
            self.tree_audit.heading(c, text=c)
            self.tree_audit.column(c, width=w, anchor="w")
        self.tree_audit.column("id", width=60, anchor="center")
        self.tree_audit.pack(fill="both", expand=True)

        self.tree_notes.bind("<<TreeviewSelect>>", self.refresh_audit_for_selected_note)

    def add_module(self):
        code = self.e_mod_code.get().strip()
        nom = self.e_mod_nom.get().strip()
        coef_txt = self.e_mod_coef.get().strip()
        credits_txt = self.e_mod_credits.get().strip()
        semestre = self.cb_mod_semestre.get().strip() if self.cb_mod_semestre.get() else None

        if not code or not nom or not coef_txt:
            messagebox.showerror("Erreur", "Code, nom et coefficient sont obligatoires.")
            return

        try:
            coef = float(coef_txt.replace(",", "."))
        except ValueError:
            messagebox.showerror("Erreur", "Coefficient invalide (ex: 2 ou 1.5).")
            return

        credits = None
        if credits_txt:
            if not credits_txt.isdigit():
                messagebox.showerror("Erreur", "Crédits doit être un entier (ex: 5).")
                return
            credits = int(credits_txt)

        conn = db_connect()
        cur = conn.cursor()
        try:
            cur.execute("""
                INSERT INTO modules (code, nom, coefficient, credits, semestre, filiere_id, niveau_id)
                VALUES (?, ?, ?, ?, ?, NULL, NULL)
            """, (code, nom, coef, credits, semestre))
            conn.commit()
            messagebox.showinfo("Succès", f"Module '{code}' créé avec succès.\nVous pouvez maintenant l'associer à une filière/niveau à l'étape 2.")
        except sqlite3.IntegrityError:
            messagebox.showerror("Erreur", "Code module déjà utilisé.")
        finally:
            conn.close()

        self.e_mod_code.delete(0, tk.END)
        self.e_mod_nom.delete(0, tk.END)
        self.e_mod_coef.delete(0, tk.END)
        self.e_mod_credits.delete(0, tk.END)
        self.cb_mod_semestre.set("")

        self.refresh_all()

    def refresh_modules_list(self):
        if not hasattr(self, "list_modules"):
            return
        self.list_modules.delete(0, tk.END)

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT m.id, m.code, m.nom, m.coefficient, COALESCE(m.credits, ''),
                   COALESCE(m.semestre, ''), COALESCE(f.code,''), COALESCE(n.code,'')
            FROM modules m
            LEFT JOIN filieres f ON f.id = m.filiere_id
            LEFT JOIN niveaux n  ON n.id = m.niveau_id
            ORDER BY m.code
        """)
        self._modules = cur.fetchall()
        conn.close()

        for (mid, code, nom, coef, credits, semestre, fcode, ncode) in self._modules:
            tag = f"{fcode}/{ncode}" if (fcode or ncode) else "(non associé)"
            sem_info = f"- {semestre}" if semestre else ""
            self.list_modules.insert(tk.END, f"{mid} - {code} - {nom} (coef={coef}, cr={credits}) {sem_info} {tag}")

        vals_mod = [f"{mid} - {code} - {nom}" for (mid, code, nom, _, _, _, _, _) in self._modules]
        if hasattr(self, "cb_note_module"): self.cb_note_module["values"] = vals_mod
        if hasattr(self, "cb_abs_module"): self.cb_abs_module["values"] = vals_mod
        if hasattr(self, "cb_aff_module"): self.cb_aff_module["values"] = vals_mod
        if hasattr(self, "cb_mod_select"): self.cb_mod_select["values"] = vals_mod

    def associate_module(self):
        """Étape 2: Associer un module à une filière et/ou niveau (optionnel)"""
        mod_sel = self.cb_mod_select.get().strip()
        if not mod_sel:
            messagebox.showerror("Erreur", "Veuillez sélectionner un module.")
            return

        mod_id = self.parse_id_from_combo(mod_sel)
        if not mod_id:
            messagebox.showerror("Erreur", "Module invalide.")
            return

        filiere_id = self.parse_id_from_combo(self.cb_mod_filiere.get()) if self.cb_mod_filiere.get() else None
        niveau_id = self.parse_id_from_combo(self.cb_mod_niveau.get()) if self.cb_mod_niveau.get() else None

        if not filiere_id and not niveau_id:
            messagebox.showwarning("Avertissement", "Veuillez sélectionner au moins une filière ou un niveau.")
            return

        conn = db_connect()
        cur = conn.cursor()
        try:
            cur.execute("""
                UPDATE modules
                SET filiere_id = ?, niveau_id = ?
                WHERE id = ?
            """, (filiere_id, niveau_id, mod_id))
            conn.commit()
            
            filiere_str = self.cb_mod_filiere.get() if self.cb_mod_filiere.get() else "(aucune)"
            niveau_str = self.cb_mod_niveau.get() if self.cb_mod_niveau.get() else "(aucun)"
            messagebox.showinfo("Succès", f"Module associé à:\n- Filière: {filiere_str}\n- Niveau: {niveau_str}")
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors de l'association: {str(e)}")
        finally:
            conn.close()

        self.cb_mod_select.set("")
        self.cb_mod_filiere.set("")
        self.cb_mod_niveau.set("")
        self.refresh_all()

    def add_note(self):
        etu_id = self.parse_id_from_combo(self.cb_note_etudiant.get())
        mod_id = self.parse_id_from_combo(self.cb_note_module.get())
        note_txt = self.e_note.get().strip()
        
        # NOUVELLE RÉCUPÉRATION
        typ = self.cb_note_type.get().strip()
        annee = self.cb_note_annee.get().strip()

        if not (etu_id and mod_id and note_txt):
            messagebox.showerror("Erreur", "Étudiant, module et note sont obligatoires.")
            return

        try:
            note = float(note_txt.replace(",", "."))
        except ValueError:
            messagebox.showerror("Erreur", "Note invalide (ex: 14.5).")
            return

        if note < 0 or note > 20:
            messagebox.showerror("Erreur", "La note doit être entre 0 et 20.")
            return

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            INSERT INTO notes (etudiant_id, module_id, note, type_evaluation, annee_academique)
            VALUES (?, ?, ?, ?, ?)
        """, (etu_id, mod_id, note, typ if typ else None, annee if annee else None))
        note_id = cur.lastrowid

        cur.execute("""
            INSERT INTO notes_audit (note_id, action, old_value, new_value, changed_at, changed_by)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (note_id, "INSERT", None, f"note={note};type={typ};annee={annee}", now_iso(), self.username))

        conn.commit()
        conn.close()

        self.e_note.delete(0, tk.END)
        self.cb_note_type.set("")
        
        self.refresh_notes_lists()
        messagebox.showinfo("OK", "Note enregistrée.")

    def _selected_note_id(self):
        sel = self.tree_notes.selection()
        if not sel:
            return None
        values = self.tree_notes.item(sel[0], "values")
        return int(values[0])

    def update_note_selected(self):
        note_id = self._selected_note_id()
        if not note_id:
            messagebox.showerror("Erreur", "Sélectionne une note dans la table.")
            return

        note_txt = self.e_note.get().strip()
        typ = self.cb_note_type.get().strip()
        annee = self.cb_note_annee.get().strip()

        if not note_txt:
            messagebox.showerror("Erreur", "Saisis une nouvelle note dans le champ Note.")
            return

        try:
            note = float(note_txt.replace(",", "."))
        except ValueError:
            messagebox.showerror("Erreur", "Note invalide (ex: 14.5).")
            return

        if note < 0 or note > 20:
            messagebox.showerror("Erreur", "La note doit être entre 0 et 20.")
            return

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT note, COALESCE(type_evaluation,''), COALESCE(annee_academique,'') FROM notes WHERE id=?", (note_id,))
        old = cur.fetchone()
        if not old:
            conn.close()
            messagebox.showerror("Erreur", "Note introuvable.")
            return

        cur.execute("""
            UPDATE notes
            SET note=?, type_evaluation=?, annee_academique=?
            WHERE id=?
        """, (note, typ if typ else None, annee if annee else None, note_id))

        cur.execute("""
            INSERT INTO notes_audit (note_id, action, old_value, new_value, changed_at, changed_by)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (
            note_id,
            "UPDATE",
            f"note={old[0]};type={old[1]};annee={old[2]}",
            f"note={note};type={typ};annee={annee}",
            now_iso(),
            self.username
        ))

        conn.commit()
        conn.close()

        self.refresh_notes_lists()
        self.refresh_audit_for_selected_note()
        messagebox.showinfo("OK", "Note modifiée (traçabilité enregistrée).")

    def delete_note_selected(self):
        note_id = self._selected_note_id()
        if not note_id:
            messagebox.showerror("Erreur", "Sélectionne une note dans la table.")
            return
        if not messagebox.askyesno("Confirmer", "Supprimer la note sélectionnée ?"):
            return

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT note, COALESCE(type_evaluation,''), COALESCE(annee_academique,'') FROM notes WHERE id=?", (note_id,))
        old = cur.fetchone()

        cur.execute("""
            INSERT INTO notes_audit (note_id, action, old_value, new_value, changed_at, changed_by)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (
            note_id,
            "DELETE",
            f"note={old[0]};type={old[1]};annee={old[2]}" if old else None,
            None,
            now_iso(),
            self.username
        ))

        cur.execute("DELETE FROM notes WHERE id=?", (note_id,))
        conn.commit()
        conn.close()

        self.refresh_notes_lists()
        for r in self.tree_audit.get_children():
            self.tree_audit.delete(r)
        messagebox.showinfo("OK", "Note supprimée.")

    def refresh_notes_lists(self):
        if not hasattr(self, "tree_notes"):
            return
        for row in self.tree_notes.get_children():
            self.tree_notes.delete(row)

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT no.id,
                   e.matricule || ' - ' || e.nom || ' ' || e.prenom AS etu,
                   m.code || ' - ' || m.nom AS mod,
                   no.note,
                   m.coefficient,
                   COALESCE(no.annee_academique,''),
                   COALESCE(no.type_evaluation,'')
            FROM notes no
            JOIN etudiants e ON e.id = no.etudiant_id
            JOIN modules m   ON m.id = no.module_id
            ORDER BY no.id DESC
        """)
        rows = cur.fetchall()
        conn.close()

        for r in rows:
            self.tree_notes.insert("", "end", values=r)

    def refresh_audit_for_selected_note(self, event=None):
        note_id = self._selected_note_id()
        if not note_id:
            return
        for row in self.tree_audit.get_children():
            self.tree_audit.delete(row)

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT id, action, COALESCE(old_value,''), COALESCE(new_value,''), COALESCE(changed_at,''), COALESCE(changed_by,'')
            FROM notes_audit
            WHERE note_id=?
            ORDER BY id DESC
        """, (note_id,))
        rows = cur.fetchall()
        conn.close()

        for r in rows:
            self.tree_audit.insert("", "end", values=r)

    def compute_moyenne(self):
        etu_id = self.parse_id_from_combo(self.cb_note_etudiant.get())
        if not etu_id:
            messagebox.showerror("Erreur", "Choisis un étudiant.")
            return

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT SUM(no.note * m.coefficient) AS total_points,
                   SUM(m.coefficient) AS total_coef
            FROM notes no
            JOIN modules m ON m.id = no.module_id
            WHERE no.etudiant_id = ?
        """, (etu_id,))
        row = cur.fetchone()
        conn.close()

        if not row or row[0] is None or row[1] is None or row[1] == 0:
            self.lbl_moyenne.config(text="Moyenne: - (aucune note)")
            return

        moyenne = row[0] / row[1]
        self.lbl_moyenne.config(text=f"Moyenne: {moyenne:.2f} / 20")

    # ABSENCES

    def build_absences_tab(self):
        frm = ttk.Frame(self.tab_absences, padding=10)
        frm.pack(fill="both", expand=True)

        top = ttk.LabelFrame(frm, text="Enregistrer une absence", padding=10)
        top.pack(fill="x")

        ttk.Label(top, text="Étudiant").grid(row=0, column=0, sticky="w", pady=4)
        ttk.Label(top, text="Module").grid(row=1, column=0, sticky="w", pady=4)
        ttk.Label(top, text="Date (YYYY-MM-DD)").grid(row=2, column=0, sticky="w", pady=4)
        ttk.Label(top, text="Justifiée").grid(row=3, column=0, sticky="w", pady=4)
        ttk.Label(top, text="Motif").grid(row=4, column=0, sticky="w", pady=4)

        self.cb_abs_etudiant = ttk.Combobox(top, width=60, state="readonly")
        self.cb_abs_module = ttk.Combobox(top, width=60, state="readonly")
        
        # MODIFICATION : Utilisation du DatePickerEntry
        self.e_abs_date = DatePickerEntry(top) 
        
        self.var_justifiee = tk.IntVar()
        self.chk_just = ttk.Checkbutton(top, variable=self.var_justifiee)
        self.e_abs_motif = ttk.Entry(top, width=40)

        self.cb_abs_etudiant.grid(row=0, column=1, pady=4, sticky="w")
        self.cb_abs_module.grid(row=1, column=1, pady=4, sticky="w")
        self.e_abs_date.grid(row=2, column=1, pady=4, sticky="ew")
        self.chk_just.grid(row=3, column=1, pady=4, sticky="w")
        self.e_abs_motif.grid(row=4, column=1, pady=4, sticky="w")

        # Bouton nommé pour changer son texte dynamiquement
        self.btn_abs_action = ttk.Button(top, text="Enregistrer absence", command=self.add_absence)
        self.btn_abs_action.grid(row=5, column=1, sticky="e", pady=8)

        bottom = ttk.LabelFrame(frm, text="Historique des absences", padding=10)
        bottom.pack(fill="both", expand=True, pady=(10, 0))

        cols = ("id", "etudiant", "module", "date", "justifiee", "motif")
        self.tree_absences = ttk.Treeview(bottom, columns=cols, show="headings")
        for c in cols:
            self.tree_absences.heading(c, text=c)
            self.tree_absences.column(c, width=160, anchor="w")
        self.tree_absences.column("id", width=60, anchor="center")
        self.tree_absences.pack(fill="both", expand=True)

        # AJOUT : Boutons Modifier / Supprimer
        btns_abs = ttk.Frame(bottom)
        btns_abs.pack(fill="x", pady=(5, 0))
        ttk.Button(btns_abs, text="Modifier absence", command=self.load_absence_to_edit).pack(side="left", padx=4)
        ttk.Button(btns_abs, text="Supprimer absence", command=self.delete_absence).pack(side="left", padx=4)

        ana = ttk.LabelFrame(frm, text="Analyse absences", padding=10)
        ana.pack(fill="x", pady=(10, 0))

        ttk.Label(ana, text="Seuil alerte (nb absences)").grid(row=0, column=0, sticky="w")
        self.e_abs_seuil = ttk.Entry(ana, width=10)
        self.e_abs_seuil.insert(0, "3")
        self.e_abs_seuil.grid(row=0, column=1, padx=8)

        ttk.Button(ana, text="Afficher alertes", command=self.show_absence_alerts).grid(row=0, column=2, padx=6)
        self.lbl_abs_stats = ttk.Label(ana, text="Taux: - | Alertes: -")
        self.lbl_abs_stats.grid(row=0, column=3, padx=10, sticky="w")

    def add_absence(self):
        etu_id = self.parse_id_from_combo(self.cb_abs_etudiant.get())
        mod_id = self.parse_id_from_combo(self.cb_abs_module.get())
        date_abs = self.e_abs_date.get().strip() # Récupère YYYY-MM-DD depuis le DatePicker
        just = self.var_justifiee.get()
        motif = self.e_abs_motif.get().strip()

        if not (etu_id and mod_id and date_abs):
            messagebox.showerror("Erreur", "Étudiant, module et date sont obligatoires.")
            return

        conn = db_connect()
        cur = conn.cursor()
        try:
            # GESTION AJOUT vs MODIFICATION
            if hasattr(self, 'current_edit_absence_id'):
                cur.execute("""
                    UPDATE absences 
                    SET etudiant_id=?, module_id=?, date_absence=?, justifiee=?, motif=?
                    WHERE id=?
                """, (etu_id, mod_id, date_abs, just, motif if motif else None, self.current_edit_absence_id))
                
                messagebox.showinfo("Succès", "Absence modifiée.")
                del self.current_edit_absence_id
                self.btn_abs_action.config(text="Enregistrer absence")
            else:
                cur.execute("""
                    INSERT INTO absences (etudiant_id, module_id, date_absence, justifiee, motif)
                    VALUES (?, ?, ?, ?, ?)
                """, (etu_id, mod_id, date_abs, just, motif if motif else None))
                
                messagebox.showinfo("Succès", "Absence enregistrée.")
            
            conn.commit()
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur SQL: {e}")
        finally:
            conn.close()

        # Réinitialisation
        self.e_abs_motif.delete(0, tk.END)
        self.var_justifiee.set(0)        
        self.refresh_absences()


    def load_absence_to_edit(self):
        sel = self.tree_absences.selection()
        if not sel:
            messagebox.showerror("Erreur", "Sélectionnez une absence dans la liste.")
            return

        values = self.tree_absences.item(sel[0], 'values')
        abs_id = int(values[0]) 

        conn = db_connect()
        cur = conn.cursor()
        # On récupère les IDs bruts pour remplir les combobox correctement
        cur.execute("SELECT etudiant_id, module_id, date_absence, justifiee, motif FROM absences WHERE id=?", (abs_id,))
        row = cur.fetchone()
        conn.close()

        if not row:
            return

        etu_id, mod_id, date_val, just_val, motif_val = row

        # Remplir les champs
        # Pour les combobox, on cherche l'élément qui commence par l'ID
        for v in self.cb_abs_etudiant['values']:
            if v.startswith(f"{etu_id} -"):
                self.cb_abs_etudiant.set(v)
                break
        
        for v in self.cb_abs_module['values']:
            if v.startswith(f"{mod_id} -"):
                self.cb_abs_module.set(v)
                break

        self.e_abs_date.set(date_val)
        self.var_justifiee.set(just_val)
        self.e_abs_motif.delete(0, tk.END)
        self.e_abs_motif.insert(0, motif_val or "")

        # Mode édition activé
        self.current_edit_absence_id = abs_id
        self.btn_abs_action.config(text="Valider la modification")

    def delete_absence(self):
        """Supprimer l'absence sélectionnée"""
        sel = self.tree_absences.selection()
        if not sel:
            messagebox.showerror("Erreur", "Sélectionnez une absence.")
            return

        if not messagebox.askyesno("Confirmation", "Supprimer cette absence définitivement ?"):
            return

        abs_id = int(self.tree_absences.item(sel[0], 'values')[0])

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("DELETE FROM absences WHERE id=?", (abs_id,))
        conn.commit()
        conn.close()

        self.refresh_absences()
        # Mettre à jour les stats instantanément
        self.refresh_dashboard()


    def refresh_absences(self):
        if not hasattr(self, "tree_absences"):
            return

        for row in self.tree_absences.get_children():
            self.tree_absences.delete(row)

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT a.id,
                   e.nom || ' ' || e.prenom,
                   m.code || ' - ' || m.nom,
                   a.date_absence,
                   CASE a.justifiee WHEN 1 THEN 'Oui' ELSE 'Non' END,
                   COALESCE(a.motif,'')
            FROM absences a
            JOIN etudiants e ON e.id = a.etudiant_id
            JOIN modules m ON m.id = a.module_id
            ORDER BY a.date_absence DESC
        """)
        rows = cur.fetchall()

        cur.execute("SELECT COUNT(*) FROM absences")
        total_abs = cur.fetchone()[0]
        cur.execute("SELECT COUNT(*) FROM etudiants")
        nb_etu = cur.fetchone()[0]

        conn.close()

        for r in rows:
            self.tree_absences.insert("", "end", values=r)

        taux = (total_abs / nb_etu) if nb_etu else 0.0
        self.lbl_abs_stats.config(text=f"Taux: {taux:.2f} abs/étudiant | Alertes: -")

    def show_absence_alerts(self):
        try:
            seuil = int(self.e_abs_seuil.get().strip())
        except ValueError:
            messagebox.showerror("Erreur", "Seuil invalide.")
            return

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT e.matricule, e.nom || ' ' || e.prenom, COUNT(*) as nb
            FROM absences a
            JOIN etudiants e ON e.id=a.etudiant_id
            GROUP BY a.etudiant_id
            HAVING nb >= ?
            ORDER BY nb DESC
        """, (seuil,))
        rows = cur.fetchall()
        conn.close()

        if not rows:
            messagebox.showinfo("Alertes", "Aucune alerte.")
            t = self.lbl_abs_stats.cget("text").split("|")[0].strip()
            self.lbl_abs_stats.config(text=f"{t} | Alertes: 0")
            return

        txt = "\n".join([f"{m} - {n} : {k} absence(s)" for m, n, k in rows])
        messagebox.showinfo("Alertes absences", txt)
        t = self.lbl_abs_stats.cget("text").split("|")[0].strip()
        self.lbl_abs_stats.config(text=f"{t} | Alertes: {len(rows)}")

    # ENSEIGNANTS

    def build_enseignants_tab(self):
        frm = ttk.Frame(self.tab_enseignants, padding=10)
        frm.pack(fill="both", expand=True)

        left = ttk.LabelFrame(frm, text="Ajouter enseignant", padding=10)
        left.pack(side="left", fill="y", padx=(0, 10))

        ttk.Label(left, text="Nom").grid(row=0, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Prénom").grid(row=1, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Email").grid(row=2, column=0, sticky="w", pady=4)

        self.e_ens_nom = ttk.Entry(left, width=26)
        self.e_ens_pre = ttk.Entry(left, width=26)
        self.e_ens_mail = ttk.Entry(left, width=26)

        self.e_ens_nom.grid(row=0, column=1, pady=4)
        self.e_ens_pre.grid(row=1, column=1, pady=4)
        self.e_ens_mail.grid(row=2, column=1, pady=4)

        ttk.Button(left, text="Ajouter", command=self.add_enseignant).grid(row=3, column=1, sticky="e", pady=8)

        ttk.Separator(left, orient="horizontal").grid(row=4, column=0, columnspan=2, sticky="ew", pady=10)

        ttk.Label(left, text="Affecter un module").grid(row=5, column=0, columnspan=2, sticky="w")
        ttk.Label(left, text="Enseignant").grid(row=6, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Module").grid(row=7, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Filière").grid(row=8, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Niveau").grid(row=9, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Spécialité").grid(row=10, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Groupe").grid(row=11, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Année").grid(row=12, column=0, sticky="w", pady=4)

        self.cb_aff_ens = ttk.Combobox(left, width=40, state="readonly")
        self.cb_aff_module = ttk.Combobox(left, width=40, state="readonly")
        self.cb_aff_filiere = ttk.Combobox(left, width=40, state="readonly")
        self.cb_aff_niveau = ttk.Combobox(left, width=40, state="readonly")
        self.cb_aff_specialite = ttk.Combobox(left, width=40, state="readonly")
        self.cb_aff_groupe = ttk.Combobox(left, width=40, state="readonly")
        
        # MODIFICATION : Champ Année dynamique (Année courante + 1 jusqu'à -5 ans)
        curr_year = datetime.now().year
        annees = [str(y) for y in range(curr_year + 1, curr_year - 5, -1)]
        self.cb_aff_annee = ttk.Combobox(left, values=annees, width=18)
        self.cb_aff_annee.set(str(curr_year)) # Valeur par défaut
        
        # Placement boutons et champs affectation
        self.cb_aff_ens.grid(row=6, column=1, pady=4, sticky="w")
        self.cb_aff_module.grid(row=7, column=1, pady=4, sticky="w")
        self.cb_aff_filiere.grid(row=8, column=1, pady=4, sticky="w")
        self.cb_aff_niveau.grid(row=9, column=1, pady=4, sticky="w")
        self.cb_aff_specialite.grid(row=10, column=1, pady=4, sticky="w")
        self.cb_aff_groupe.grid(row=11, column=1, pady=4, sticky="w")
        self.cb_aff_annee.grid(row=12, column=1, pady=4, sticky="w")

        ttk.Button(left, text="Affecter", command=self.add_affectation).grid(row=13, column=1, sticky="e", pady=6)

        right = ttk.LabelFrame(frm, text="Enseignants & affectations", padding=10)
        right.pack(side="left", fill="both", expand=True)

        cols = ("id", "nom", "prenom", "email")
        self.tree_ens = ttk.Treeview(right, columns=cols, show="headings")
        for c in cols:
            self.tree_ens.heading(c, text=c)
            self.tree_ens.column(c, width=200, anchor="w")
        self.tree_ens.column("id", width=60, anchor="center")
        self.tree_ens.pack(fill="both", expand=True)

        cols2 = ("id", "enseignant", "module", "groupe", "annee")
        self.tree_aff = ttk.Treeview(right, columns=cols2, show="headings")
        for c in cols2:
            self.tree_aff.heading(c, text=c)
            self.tree_aff.column(c, width=220, anchor="w")
        self.tree_aff.column("id", width=60, anchor="center")
        self.tree_aff.pack(fill="both", expand=True, pady=(10, 0))

        # Buttons for managing enseignants/affectations
        btn_frame = ttk.Frame(right)
        btn_frame.pack(fill="x", pady=(8,0))
        ttk.Button(btn_frame, text="Modifier enseignant", command=self.edit_enseignant).pack(side="left", padx=4)
        ttk.Button(btn_frame, text="Supprimer enseignant", command=self.delete_enseignant).pack(side="left", padx=4)
        ttk.Button(btn_frame, text="Modifier affectation", command=self.load_affectation_to_edit).pack(side="right", padx=4)
        ttk.Button(btn_frame, text="Supprimer affectation", command=self.delete_affectation).pack(side="right", padx=4)

    def add_enseignant(self):
        nom = self.e_ens_nom.get().strip()
        prenom = self.e_ens_pre.get().strip()
        email = self.e_ens_mail.get().strip() or None

        if not nom or not prenom:
            messagebox.showerror("Erreur", "Nom et prénom obligatoires.")
            return

        conn = db_connect()
        cur = conn.cursor()
        try:
            cur.execute("INSERT INTO enseignants (nom, prenom, email) VALUES (?, ?, ?)", (nom, prenom, email))
            conn.commit()
        except sqlite3.IntegrityError:
            messagebox.showerror("Erreur", "Email déjà utilisé.")
        finally:
            conn.close()

        self.e_ens_nom.delete(0, tk.END)
        self.e_ens_pre.delete(0, tk.END)
        self.e_ens_mail.delete(0, tk.END)
        self.refresh_enseignants()

    def edit_enseignant(self):
        sel = self.tree_ens.selection()
        if not sel:
            messagebox.showerror("Erreur", "Sélectionnez d'abord un enseignant.")
            return
        values = self.tree_ens.item(sel[0], 'values')
        ens_id = int(values[0])

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT nom, prenom, email FROM enseignants WHERE id=?", (ens_id,))
        row = cur.fetchone()
        conn.close()
        if not row:
            messagebox.showerror("Erreur", "Enseignant introuvable.")
            return

        self.e_ens_nom.delete(0, tk.END)
        self.e_ens_nom.insert(0, row[0])
        self.e_ens_pre.delete(0, tk.END)
        self.e_ens_pre.insert(0, row[1])
        self.e_ens_mail.delete(0, tk.END)
        self.e_ens_mail.insert(0, row[2] or "")
        self.current_edit_enseignant_id = ens_id

    def delete_enseignant(self):
        sel = self.tree_ens.selection()
        if not sel:
            messagebox.showerror("Erreur", "Sélectionnez d'abord un enseignant.")
            return
        values = self.tree_ens.item(sel[0], 'values')
        ens_id = int(values[0])
        if not messagebox.askyesno("Confirmation", "Supprimer cet enseignant et toutes ses affectations ?"):
            return
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("DELETE FROM enseignants WHERE id=?", (ens_id,))
        conn.commit()
        conn.close()
        self.refresh_enseignants()

    def delete_affectation(self):
        sel = self.tree_aff.selection()
        if not sel:
            messagebox.showerror("Erreur", "Sélectionnez d'abord une affectation.")
            return
        values = self.tree_aff.item(sel[0], 'values')
        aff_id = int(values[0])
        if not messagebox.askyesno("Confirmation", "Supprimer cette affectation ?"):
            return
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("DELETE FROM enseignements WHERE id=?", (aff_id,))
        conn.commit()
        conn.close()
        self.refresh_enseignants()

    def load_affectation_to_edit(self, event=None):
        sel = self.tree_aff.selection()
        if not sel:
            messagebox.showerror("Erreur", "Sélectionnez d'abord une affectation.")
            return
        values = self.tree_aff.item(sel[0], 'values')
        aff_id = int(values[0])

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT en.enseignant_id, en.module_id, m.filiere_id, m.niveau_id, en.groupe, en.annee_academique 
            FROM enseignements en
            JOIN modules m ON m.id = en.module_id
            WHERE en.id=?
        """, (aff_id,))
        row = cur.fetchone()
        conn.close()
        if not row:
            messagebox.showerror("Erreur", "Affectation introuvable.")
            return

        ens_id, mod_id, fil_id, niv_id, groupe, annee = row
        
        # Set comboboxes
        for v in self.cb_aff_ens['values']:
            if v.startswith(f"{ens_id} -"):
                self.cb_aff_ens.set(v)
                break
        for v in self.cb_aff_module['values']:
            if v.startswith(f"{mod_id} -"):
                self.cb_aff_module.set(v)
                break
        
        # Set filière/niveau/groupe based on module
        if fil_id:
            for v in self.cb_aff_filiere['values']:
                if v.startswith(f"{fil_id} -"):
                    self.cb_aff_filiere.set(v)
                    break
        if niv_id:
            for v in self.cb_aff_niveau['values']:
                if v.startswith(f"{niv_id} -"):
                    self.cb_aff_niveau.set(v)
                    break
        
        if groupe:
            for v in self.cb_groupe['values']:
                if v.startswith(f"{groupe} -"):  # On cherche par ID
                    self.cb_groupe.set(v)
                    break
        
        self.cb_aff_annee.set(annee or "")
        
        self.current_edit_affectation_id = aff_id

    def on_aff_filiere_selected(self, event=None):
        fil_text = self.cb_aff_filiere.get()
        if not fil_text: return
        
        fil_id = self.parse_id_from_combo(fil_text)
        
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT id, nom FROM specialites WHERE filiere_id=? ORDER BY nom", (fil_id,))
        specs = cur.fetchall()
        conn.close()
        
        # On remplit la combobox des spécialités
        self.cb_aff_specialite['values'] = [f"{sid} - {nom}" for (sid, nom) in specs]
        self.cb_aff_specialite.set("")

    def on_aff_niveau_selected(self, event=None):
        """Charger les groupes associés au niveau sélectionné"""
        fil_text = self.cb_aff_filiere.get()
        niv_text = self.cb_aff_niveau.get()
        
        if not fil_text or not niv_text:
            return
        
        try:
            fil_id = int(fil_text.split(" - ")[0])
            niv_id = int(niv_text.split(" - ")[0])
        except (ValueError, IndexError):
            return
        
        # Load groupes for this filière+niveau
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT DISTINCT groupe_id FROM inscriptions 
            WHERE filiere_id=? AND niveau_id=? AND groupe_id IS NOT NULL
            ORDER BY groupe_id
        """, (fil_id, niv_id))
        groupes = cur.fetchall()
        conn.close()
        
        groupe_values = [str(row[0]) for row in groupes] if groupes else []
        # Also add default groups
        for i in range(1, 11):
            g_str = f"Groupe {i}"
            if g_str not in groupe_values:
                groupe_values.append(g_str)
        
        self.cb_aff_groupe['values'] = sorted(groupe_values)
        self.cb_aff_groupe.set("")

    def add_affectation(self):
        ens_id = self.parse_id_from_combo(self.cb_aff_ens.get())
        mod_id = self.parse_id_from_combo(self.cb_aff_module.get())
        groupe = self.cb_aff_groupe.get().strip() or None
        annee = self.cb_aff_annee.get().strip() or None

        if not ens_id or not mod_id:
            messagebox.showerror("Erreur", "Enseignant et module obligatoires.")
            return

        conn = db_connect()
        cur = conn.cursor()
        try:
            # Si on est en édition d'une affectation existante, mettre à jour
            if hasattr(self, 'current_edit_affectation_id'):
                cur.execute("""
                    UPDATE enseignements SET enseignant_id=?, module_id=?, groupe=?, annee_academique=? WHERE id=?
                """, (ens_id, mod_id, groupe, annee, self.current_edit_affectation_id))
                del self.current_edit_affectation_id
            else:
                cur.execute("""
                    INSERT INTO enseignements (enseignant_id, module_id, groupe, annee_academique)
                    VALUES (?, ?, ?, ?)
                """, (ens_id, mod_id, groupe, annee))
            conn.commit()
        except sqlite3.IntegrityError:
            messagebox.showerror("Erreur", "Affectation déjà existante.")
        finally:
            conn.close()

        self.refresh_enseignants()
        messagebox.showinfo("OK", "Affectation enregistrée.")

    def refresh_enseignants(self):
        if not hasattr(self, "tree_ens"):
            return

        for r in self.tree_ens.get_children():
            self.tree_ens.delete(r)
        for r in self.tree_aff.get_children():
            self.tree_aff.delete(r)

        conn = db_connect()
        cur = conn.cursor()
        
        # 1. Charger les enseignants
        cur.execute("SELECT id, nom, prenom, COALESCE(email,'') FROM enseignants ORDER BY nom, prenom")
        ens = cur.fetchall()
        self.cb_aff_ens["values"] = [f"{eid} - {n} {p}" for (eid, n, p, _) in ens]
        for row in ens:
            self.tree_ens.insert("", "end", values=row)

        # 2. CHARGEMENT DES CHAMPS MANQUANTS (Correction)
        # Filières
        cur.execute("SELECT id, code, nom FROM filieres ORDER BY code")
        self.cb_aff_filiere["values"] = [f"{fid} - {code} - {nom}" for (fid, code, nom) in cur.fetchall()]
        
        # Niveaux
        cur.execute("SELECT id, code, nom FROM niveaux ORDER BY ordre")
        self.cb_aff_niveau["values"] = [f"{nid} - {code} - {nom}" for (nid, code, nom) in cur.fetchall()]
        
        # Groupes
        cur.execute("SELECT id, code, nom FROM groupes ORDER BY code")
        self.cb_aff_groupe["values"] = [f"{gid} - {code} - {nom}" for (gid, code, nom) in cur.fetchall()]

        # 3. Charger les affectations existantes
        cur.execute("""
            SELECT en.id, e.nom || ' ' || e.prenom, m.code || ' - ' || m.nom,
                COALESCE(en.groupe,''), COALESCE(en.annee_academique,'')
            FROM enseignements en
            JOIN enseignants e ON e.id=en.enseignant_id
            JOIN modules m ON m.id=en.module_id
            ORDER BY en.id DESC
        """)
        aff = cur.fetchall()
        conn.close()

        for row in aff:
            self.tree_aff.insert("", "end", values=row)

    # CALENDRIER

    def build_calendrier_tab(self):
        frm = ttk.Frame(self.tab_calendrier, padding=10)
        frm.pack(fill="both", expand=True)

        left = ttk.LabelFrame(frm, text="Semestres", padding=10)
        left.pack(side="left", fill="both", expand=True, padx=(0, 10))

        ttk.Label(left, text="Code (ex: S1)").grid(row=0, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Libellé").grid(row=1, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Début").grid(row=2, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Fin").grid(row=3, column=0, sticky="w", pady=4)

        self.e_sem_code = ttk.Entry(left, width=18)
        self.e_sem_lib = ttk.Entry(left, width=28)
        self.e_sem_deb = DatePickerEntry(left)
        self.e_sem_fin = DatePickerEntry(left)

        self.e_sem_code.grid(row=0, column=1, pady=4, sticky="w")
        self.e_sem_lib.grid(row=1, column=1, pady=4, sticky="w")
        self.e_sem_deb.grid(row=2, column=1, pady=4, sticky="ew")
        self.e_sem_fin.grid(row=3, column=1, pady=4, sticky="ew")

        # Remplacer : ttk.Button(left, text="Ajouter semestre", command=self.add_semestre).grid(row=4, column=1, sticky="e", pady=8)
        self.btn_sem_action = ttk.Button(left, text="Ajouter semestre", command=self.add_semestre)
        self.btn_sem_action.grid(row=4, column=1, sticky="e", pady=8)

        self.tree_sem = ttk.Treeview(left, columns=("id", "code", "lib", "deb", "fin"), show="headings")
        for c, w in [("id", 60), ("code", 80), ("lib", 220), ("deb", 120), ("fin", 120)]:
            self.tree_sem.heading(c, text=c)
            self.tree_sem.column(c, width=w, anchor="w")
        self.tree_sem.column("id", width=60, anchor="center")
        self.tree_sem.grid(row=5, column=0, columnspan=2, sticky="nsew", pady=(10, 0))

        # AJOUT : Boutons d'action pour les semestres
        btns_sem = ttk.Frame(left)
        btns_sem.grid(row=6, column=0, columnspan=2, sticky="ew", pady=(8, 0))
        ttk.Button(btns_sem, text="Modifier sélection", command=self.load_semestre_to_edit).pack(side="left", padx=4)
        ttk.Button(btns_sem, text="Supprimer sélection", command=self.delete_semestre).pack(side="left", padx=4)

        right = ttk.LabelFrame(frm, text="Périodes (cours/examens/vacances)", padding=10)
        right.pack(side="left", fill="both", expand=True)

        ttk.Label(right, text="Semestre").grid(row=0, column=0, sticky="w", pady=4)
        ttk.Label(right, text="Type").grid(row=1, column=0, sticky="w", pady=4)
        ttk.Label(right, text="Libellé").grid(row=2, column=0, sticky="w", pady=4)
        ttk.Label(right, text="Début").grid(row=3, column=0, sticky="w", pady=4)
        ttk.Label(right, text="Fin").grid(row=4, column=0, sticky="w", pady=4)

        self.cb_per_sem = ttk.Combobox(right, width=40, state="readonly")
        
        # MODIFICATION : Liste déroulante pour les types
        types_periodes = ["Cours", "Examens", "Vacances", "Vacances d'été", "Férié", "Stage", "Soutenance", "Rattrapage"]
        self.cb_per_type = ttk.Combobox(right, values=types_periodes, width=20, state="readonly")
        
        self.e_per_lib = ttk.Entry(right, width=28)
        self.e_per_deb = DatePickerEntry(right)
        self.e_per_fin = DatePickerEntry(right)
        
        # Bouton d'ajout pour les périodes
        self.btn_per_action = ttk.Button(right, text="Ajouter période", command=self.add_periode)
        self.btn_per_action.grid(row=5, column=1, sticky="e", pady=8)

        self.cb_per_sem.grid(row=0, column=1, pady=4, sticky="w")
        self.cb_per_type.grid(row=1, column=1, pady=4, sticky="w")
        self.e_per_lib.grid(row=2, column=1, pady=4, sticky="w")
        self.e_per_deb.grid(row=3, column=1, pady=4, sticky="ew")
        self.e_per_fin.grid(row=4, column=1, pady=4, sticky="ew")


        self.tree_per = ttk.Treeview(right, columns=("id", "sem", "type", "lib", "deb", "fin"), show="headings")
        for c, w in [("id", 60), ("sem", 120), ("type", 120), ("lib", 220), ("deb", 110), ("fin", 110)]:
            self.tree_per.heading(c, text=c)
            self.tree_per.column(c, width=w, anchor="w")
        self.tree_per.column("id", width=60, anchor="center")
        self.tree_per.grid(row=6, column=0, columnspan=2, sticky="nsew", pady=(10, 0))


        btns_per = ttk.Frame(right)
        btns_per.grid(row=7, column=0, columnspan=2, sticky="ew", pady=(8, 0))
        ttk.Button(btns_per, text="Modifier sélection", command=self.load_periode_to_edit).pack(side="left", padx=4)
        ttk.Button(btns_per, text="Supprimer sélection", command=self.delete_periode).pack(side="left", padx=4)

    def add_semestre(self):
        code = self.e_sem_code.get().strip()
        lib = self.e_sem_lib.get().strip() or None
        deb = self.e_sem_deb.get().strip()
        fin = self.e_sem_fin.get().strip()

        if not code or not deb or not fin:
            messagebox.showerror("Erreur", "Code + dates début/fin obligatoires.")
            return

        conn = db_connect()
        cur = conn.cursor()
        try:
            # GESTION MODIFICATION vs AJOUT
            if hasattr(self, 'current_edit_semestre_id'):
                cur.execute("""
                    UPDATE semestres SET code=?, libelle=?, date_debut=?, date_fin=?
                    WHERE id=?
                """, (code, lib, deb, fin, self.current_edit_semestre_id))
                messagebox.showinfo("Succès", "Semestre modifié.")
                del self.current_edit_semestre_id
                self.btn_sem_action.config(text="Ajouter semestre")
            else:
                cur.execute("INSERT INTO semestres (code, libelle, date_debut, date_fin) VALUES (?, ?, ?, ?)", 
                           (code, lib, deb, fin))
                messagebox.showinfo("Succès", "Semestre ajouté.")
            
            conn.commit()
        except sqlite3.IntegrityError:
            messagebox.showerror("Erreur", "Code semestre déjà utilisé.")
        finally:
            conn.close()

        # Nettoyage
        self.e_sem_code.delete(0, tk.END)
        self.e_sem_lib.delete(0, tk.END)
        self.e_sem_deb.delete(0, tk.END)
        self.e_sem_fin.delete(0, tk.END)
        self.refresh_calendrier()

    def load_semestre_to_edit(self):
        """Charger le semestre sélectionné pour modification"""
        sel = self.tree_sem.selection()
        if not sel:
            messagebox.showerror("Erreur", "Sélectionnez un semestre.")
            return

        values = self.tree_sem.item(sel[0], 'values')
        # values = (id, code, lib, deb, fin)
        s_id = int(values[0])
        s_code = values[1]
        s_lib = values[2]
        s_deb = values[3]
        s_fin = values[4]

        # Remplir le formulaire
        self.e_sem_code.delete(0, tk.END)
        self.e_sem_code.insert(0, s_code)
        
        self.e_sem_lib.delete(0, tk.END)
        self.e_sem_lib.insert(0, s_lib)
        
        self.e_sem_deb.set(s_deb)
        self.e_sem_fin.set(s_fin)

        # Mode édition
        self.current_edit_semestre_id = s_id
        self.btn_sem_action.config(text="Valider modification")

    def delete_semestre(self):
        """Supprimer le semestre sélectionné"""
        sel = self.tree_sem.selection()
        if not sel:
            messagebox.showerror("Erreur", "Sélectionnez un semestre.")
            return

        if not messagebox.askyesno("Attention", "Supprimer ce semestre effacera aussi les périodes associées.\nContinuer ?"):
            return

        s_id = int(self.tree_sem.item(sel[0], 'values')[0])

        conn = db_connect()
        cur = conn.cursor()
        try:
            # La suppression en cascade (ON DELETE CASCADE) gérera les périodes si configurée,
            # sinon on force le nettoyage.
            cur.execute("DELETE FROM semestres WHERE id=?", (s_id,))
            conn.commit()
            messagebox.showinfo("Succès", "Semestre supprimé.")
        except Exception as e:
            messagebox.showerror("Erreur", f"Impossible de supprimer : {e}")
        finally:
            conn.close()

        self.refresh_calendrier()

    def add_periode(self):
        sem_id = self.parse_id_from_combo(self.cb_per_sem.get())
        typ = self.cb_per_type.get().strip()
        lib = self.e_per_lib.get().strip() or None
        deb = self.e_per_deb.get().strip()
        fin = self.e_per_fin.get().strip()

        if not sem_id or not typ or not deb or not fin:
            messagebox.showerror("Erreur", "Semestre, type et dates obligatoires.")
            return

        conn = db_connect()
        cur = conn.cursor()
        try:
            if hasattr(self, 'current_edit_periode_id'):
                cur.execute("""
                    UPDATE periodes SET semestre_id=?, type=?, libelle=?, date_debut=?, date_fin=?
                    WHERE id=?
                """, (sem_id, typ, lib, deb, fin, self.current_edit_periode_id))
                messagebox.showinfo("Succès", "Période modifiée.")
                del self.current_edit_periode_id
                self.btn_per_action.config(text="Ajouter période")
            else:
                cur.execute("""
                    INSERT INTO periodes (semestre_id, type, libelle, date_debut, date_fin)
                    VALUES (?, ?, ?, ?, ?)
                """, (sem_id, typ, lib, deb, fin))
                messagebox.showinfo("Succès", "Période ajoutée.")
            conn.commit()
        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur SQL: {e}")
        finally:
            conn.close()

        # Reset des champs
        self.cb_per_type.set("")
        self.e_per_lib.delete(0, tk.END)
        self.e_per_deb.delete(0, tk.END)
        self.e_per_fin.delete(0, tk.END)
        self.refresh_calendrier()
    
    def load_periode_to_edit(self):
        """Charger la période sélectionnée pour modification"""
        sel = self.tree_per.selection()
        if not sel:
            messagebox.showerror("Erreur", "Sélectionnez une période dans la liste.")
            return

        values = self.tree_per.item(sel[0], 'values')
        # values = (id, sem_code, type, lib, deb, fin)
        p_id = int(values[0])
        p_type = values[2]
        p_lib = values[3]
        p_deb = values[4]
        p_fin = values[5]

        # Retrouver l'ID complet du semestre pour la combobox
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT semestre_id FROM periodes WHERE id=?", (p_id,))
        sem_id = cur.fetchone()[0]
        conn.close()

        # Remplir le formulaire
        for val in self.cb_per_sem['values']:
            if val.startswith(f"{sem_id} -"):
                self.cb_per_sem.set(val)
                break
        
        self.cb_per_type.set(p_type)
        self.e_per_lib.delete(0, tk.END)
        self.e_per_lib.insert(0, p_lib)
        self.e_per_deb.set(p_deb)
        self.e_per_fin.set(p_fin)

        # Passer en mode édition
        self.current_edit_periode_id = p_id
        self.btn_per_action.config(text="Valider modification")

    def delete_periode(self):
        """Supprimer la période sélectionnée"""
        sel = self.tree_per.selection()
        if not sel:
            messagebox.showerror("Erreur", "Sélectionnez une période.")
            return

        if not messagebox.askyesno("Confirmation", "Supprimer cette période ?"):
            return

        p_id = int(self.tree_per.item(sel[0], 'values')[0])

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("DELETE FROM periodes WHERE id=?", (p_id,))
        conn.commit()
        conn.close()

        self.refresh_calendrier()

    def refresh_calendrier(self):
        if not hasattr(self, "tree_sem"):
            return
        for r in self.tree_sem.get_children():
            self.tree_sem.delete(r)
        for r in self.tree_per.get_children():
            self.tree_per.delete(r)

        conn = db_connect()
        cur = conn.cursor()

        cur.execute("SELECT id, code, COALESCE(libelle,''), date_debut, date_fin FROM semestres ORDER BY date_debut")
        sem = cur.fetchall()
        for row in sem:
            self.tree_sem.insert("", "end", values=row)

        self.cb_per_sem["values"] = [f"{sid} - {code} ({deb}→{fin})" for (sid, code, _, deb, fin) in sem]

        cur.execute("""
            SELECT p.id, s.code, p.type, COALESCE(p.libelle,''), p.date_debut, p.date_fin
            FROM periodes p
            JOIN semestres s ON s.id=p.semestre_id
            ORDER BY p.date_debut
        """)
        per = cur.fetchall()
        conn.close()

        for row in per:
            self.tree_per.insert("", "end", values=row)

    # DASHBOARD

    def build_dashboard_tab(self):
        frm = ttk.Frame(self.tab_dashboard, padding=10)
        frm.pack(fill="both", expand=True)

        ttk.Label(frm, text="Dashboard", font=("Segoe UI", 14, "bold")).pack(anchor="w")

        self.lbl_kpis = ttk.Label(frm, text="", font=("Segoe UI", 11))
        self.lbl_kpis.pack(anchor="w", pady=(8, 10))

        # Frame pour les graphiques
        charts_frm = ttk.Frame(frm)
        charts_frm.pack(fill="both", expand=True, pady=10)

        self.canvas_grades = tk.Canvas(charts_frm, bg="white", height=250)
        self.canvas_absences = tk.Canvas(charts_frm, bg="white", height=250)
        self.canvas_grades.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        self.canvas_absences.grid(row=0, column=1, sticky="nsew", padx=5, pady=5)
        charts_frm.grid_rowconfigure(0, weight=1)
        charts_frm.grid_columnconfigure(0, weight=1)
        charts_frm.grid_columnconfigure(1, weight=1)

        # Frame pour les statistiques
        box = ttk.LabelFrame(frm, text="Top 5 étudiants avec le plus d'absences", padding=10)
        box.pack(fill="both", expand=True)

        self.tree_top_abs = ttk.Treeview(box, columns=("matricule", "etudiant", "absences"), show="headings")
        for c, w in [("matricule", 180), ("etudiant", 360), ("absences", 120)]:
            self.tree_top_abs.heading(c, text=c)
            self.tree_top_abs.column(c, width=w, anchor="w")
        self.tree_top_abs.column("absences", width=120, anchor="center")
        self.tree_top_abs.pack(fill="both", expand=True)

        ttk.Button(frm, text="Rafraîchir", command=self.refresh_dashboard).pack(anchor="e", pady=(10, 0))

    def create_grade_distribution_chart(self):
        """Crée un graphique de distribution des mentions académiques"""
        conn = db_connect()
        cur = conn.cursor()
        
        # Récupérer les données de notes
        cur.execute("SELECT note FROM notes WHERE note IS NOT NULL")
        notes = [row[0] for row in cur.fetchall()]
        conn.close()
        
        if not notes:
            return None
        
        # Créer les catégories de mentions
        mentions_count = {
            "Excellente (≥18)": len([n for n in notes if n >= 18]),
            "Très bien (≥16)": len([n for n in notes if 16 <= n < 18]),
            "Bien (≥14)": len([n for n in notes if 14 <= n < 16]),
            "Assez bien (≥12)": len([n for n in notes if 12 <= n < 14]),
            "Passable (≥10)": len([n for n in notes if 10 <= n < 12]),
            "Insuffisant (<10)": len([n for n in notes if n < 10]),
        }
        
        fig = Figure(figsize=(5, 3.5), dpi=100)
        ax = fig.add_subplot(111)
        
        mentions = list(mentions_count.keys())
        counts = list(mentions_count.values())
        colors = ['#2ecc71', '#27ae60', '#f39c12', '#e67e22', '#e74c3c', '#95a5a6']
        
        ax.bar(mentions, counts, color=colors, edgecolor='black', linewidth=0.5)
        ax.set_ylabel('Nombre d\'étudiants', fontsize=10)
        ax.set_title('Distribution des mentions académiques', fontsize=11, fontweight='bold')
        ax.tick_params(axis='x', rotation=45, labelsize=8)
        fig.tight_layout()
        
        return fig

    def create_absences_distribution_chart(self):
        """Crée un graphique de distribution des absences par niveau"""
        conn = db_connect()
        cur = conn.cursor()
        
        # Récupérer les absences par niveau
        cur.execute("""
            SELECT n.nom, COUNT(a.id) as nb_absences
            FROM absences a
            LEFT JOIN modules m ON m.id = a.module_id
            LEFT JOIN niveaux n ON n.id = (
                SELECT niveau_id FROM inscriptions WHERE etudiant_id = a.etudiant_id LIMIT 1
            )
            GROUP BY n.nom
            ORDER BY nb_absences DESC
            LIMIT 8
        """)
        data = cur.fetchall()
        conn.close()
        
        if not data:
            return None
        
        niveaux = [row[0] if row[0] else "Non assigné" for row in data]
        absences = [row[1] for row in data]
        
        fig = Figure(figsize=(5, 3.5), dpi=100)
        ax = fig.add_subplot(111)
        
        ax.barh(niveaux, absences, color='#e74c3c', edgecolor='black', linewidth=0.5)
        ax.set_xlabel('Nombre d\'absences', fontsize=10)
        ax.set_title('Absences par niveau', fontsize=11, fontweight='bold')
        ax.tick_params(axis='y', labelsize=9)
        fig.tight_layout()
        
        return fig

    def refresh_dashboard(self):
        if not hasattr(self, "lbl_kpis"):
            return

        conn = db_connect()
        cur = conn.cursor()

        cur.execute("SELECT COUNT(*) FROM etudiants")
        nb_etudiants = cur.fetchone()[0]

        cur.execute("SELECT COUNT(*) FROM modules")
        nb_modules = cur.fetchone()[0]

        cur.execute("SELECT COUNT(*) FROM inscriptions")
        nb_inscriptions = cur.fetchone()[0]

        cur.execute("SELECT COUNT(*) FROM absences")
        nb_absences = cur.fetchone()[0]

        cur.execute("""
            SELECT e.matricule, e.nom || ' ' || e.prenom, COUNT(*) as nb
            FROM absences a
            JOIN etudiants e ON e.id=a.etudiant_id
            GROUP BY a.etudiant_id
            ORDER BY nb DESC
            LIMIT 5
        """)
        top_abs = cur.fetchall()
        conn.close()

        self.lbl_kpis.config(
            text=f"Étudiants: {nb_etudiants} | Modules: {nb_modules} | "
                 f"Inscriptions: {nb_inscriptions} | Absences: {nb_absences}"
        )

        for row in self.tree_top_abs.get_children():
            self.tree_top_abs.delete(row)
        for m, e, n in top_abs:
            self.tree_top_abs.insert("", "end", values=(m, e, n))

        # Refresh charts
        try:
            # Clear previous canvases
            for widget in self.canvas_grades.winfo_children():
                widget.destroy()
            for widget in self.canvas_absences.winfo_children():
                widget.destroy()

            # Grade distribution chart
            fig_grades = self.create_grade_distribution_chart()
            if fig_grades:
                canvas_grades = FigureCanvasTkAgg(fig_grades, master=self.canvas_grades)
                canvas_grades.draw()
                canvas_grades.get_tk_widget().pack(fill="both", expand=True)

            # Absences distribution chart
            fig_absences = self.create_absences_distribution_chart()
            if fig_absences:
                canvas_absences = FigureCanvasTkAgg(fig_absences, master=self.canvas_absences)
                canvas_absences.draw()
                canvas_absences.get_tk_widget().pack(fill="both", expand=True)
        except Exception as e:
            print(f"Erreur lors du rendu des graphiques: {e}")

    # DOCUMENTS

    def build_documents_tab(self):
        frm = ttk.Frame(self.tab_documents, padding=10)
        frm.pack(fill="both", expand=True)

        ttk.Label(frm, text="Documents & Exports", font=("Segoe UI", 14, "bold")).pack(anchor="w")

        line = ttk.Frame(frm)
        line.pack(fill="x", pady=10)
        ttk.Button(line, text="Exporter notes (Excel)", command=self.export_notes_xlsx).pack(side="left", padx=6)
        ttk.Button(line, text="Exporter absences (Excel)", command=self.export_absences_xlsx).pack(side="left", padx=6)

        ttk.Separator(frm, orient="horizontal").pack(fill="x", pady=10)

        pdf = ttk.LabelFrame(frm, text="PDF", padding=10)
        pdf.pack(fill="x")

        ttk.Label(pdf, text="Étudiant").grid(row=0, column=0, sticky="w")
        self.cb_doc_etudiant = ttk.Combobox(pdf, width=70, state="readonly")
        self.cb_doc_etudiant.grid(row=0, column=1, padx=8, pady=4, sticky="w")

        ttk.Button(pdf, text="Relevé PDF", command=self.export_releve_pdf).grid(row=1, column=1, sticky="e", padx=8, pady=6)

        att = ttk.Frame(pdf)
        att.grid(row=2, column=0, columnspan=2, sticky="w", pady=6)

        ttk.Label(att, text="Année (attestation)").grid(row=0, column=0, sticky="w")
        self.e_doc_annee = ttk.Entry(att, width=20)
        self.e_doc_annee.grid(row=0, column=1, padx=8, pady=4, sticky="w")
        ttk.Button(att, text="Attestation PDF", command=self.export_attestation_pdf).grid(row=0, column=2, padx=8)

    def refresh_documents_lists(self):
        # alimenté via refresh_inscriptions_lists (cb_doc_etudiant)
        pass

    def close_app(self):
        """Ferme l'application complètement"""
        self.destroy()
        if self.root:
            self.root.quit()
        else:
            import sys
            sys.exit(0)

    def export_releve_pdf(self):
        etu_id = self.parse_id_from_combo(self.cb_doc_etudiant.get())
        if not etu_id:
            messagebox.showerror("Erreur", "Choisis un étudiant.")
            return
        path = filedialog.asksaveasfilename(defaultextension=".pdf", filetypes=[("PDF", "*.pdf")])
        if not path:
            return
        conn = db_connect()
        try:
            generate_transcript_pdf(conn, etu_id, path)
        finally:
            conn.close()
        messagebox.showinfo("OK", "Relevé PDF généré.")

    def export_attestation_pdf(self):
        etu_id = self.parse_id_from_combo(self.cb_doc_etudiant.get())
        annee = self.e_doc_annee.get().strip()
        if not etu_id or not annee:
            messagebox.showerror("Erreur", "Étudiant et année obligatoires.")
            return
        path = filedialog.asksaveasfilename(defaultextension=".pdf", filetypes=[("PDF", "*.pdf")])
        if not path:
            return
        conn = db_connect()
        try:
            generate_attestation_pdf(conn, etu_id, annee, path)
        finally:
            conn.close()
        messagebox.showinfo("OK", "Attestation PDF générée.")

    def export_notes_xlsx(self):
        path = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel", "*.xlsx")])
        if not path:
            return
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT no.id,
                   e.matricule,
                   e.nom || ' ' || e.prenom AS etudiant,
                   m.code,
                   m.nom AS module,
                   no.note,
                   m.coefficient,
                   COALESCE(no.annee_academique,'') AS annee,
                   COALESCE(no.type_evaluation,'') AS type
            FROM notes no
            JOIN etudiants e ON e.id=no.etudiant_id
            JOIN modules m ON m.id=no.module_id
            ORDER BY no.id
        """)
        rows = cur.fetchall()
        conn.close()

        export_query_to_xlsx(
            ["id", "matricule", "etudiant", "code_module", "module", "note", "coef", "annee", "type"],
            rows,
            path,
            "notes"
        )
        messagebox.showinfo("OK", "Export notes Excel terminé.")

    def export_absences_xlsx(self):
        path = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel", "*.xlsx")])
        if not path:
            return
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT a.id,
                   e.matricule,
                   e.nom || ' ' || e.prenom AS etudiant,
                   m.code,
                   m.nom AS module,
                   a.date_absence,
                   a.justifiee,
                   COALESCE(a.motif,'')
            FROM absences a
            JOIN etudiants e ON e.id=a.etudiant_id
            JOIN modules m ON m.id=a.module_id
            ORDER BY a.id
        """)
        rows = cur.fetchall()
        conn.close()

        export_query_to_xlsx(
            ["id", "matricule", "etudiant", "code_module", "module", "date_absence", "justifiee", "motif"],
            rows,
            path,
            "absences"
        )
        messagebox.showinfo("OK", "Export absences Excel terminé.")

    # GESTION UTILISATEURS

    def build_users_tab(self):
        """Construire l'interface de gestion des utilisateurs"""
        frm = ttk.Frame(self.tab_users, padding=10)
        frm.pack(fill="both", expand=True)

        ttk.Label(frm, text="Gestion des utilisateurs", font=("Segoe UI", 14, "bold")).pack(anchor="w", pady=(0, 10))

        # Section ajout/édition
        left = ttk.LabelFrame(frm, text="Ajouter/Modifier utilisateur", padding=10)
        left.pack(side="left", fill="y", padx=(0, 10))

        ttk.Label(left, text="Nom d'utilisateur *").grid(row=0, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Mot de passe *").grid(row=1, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Rôle *").grid(row=2, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Nom").grid(row=3, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Prénom").grid(row=4, column=0, sticky="w", pady=4)
        ttk.Label(left, text="Email").grid(row=5, column=0, sticky="w", pady=4)

        self.e_user_username = ttk.Entry(left, width=28)
        self.e_user_password = ttk.Entry(left, width=28, show="*")
        self.var_user_role = tk.StringVar(value="Secrétariat")
        self.cb_user_role = ttk.Combobox(left, textvariable=self.var_user_role, 
                                         values=["ADMIN", "Enseignant", "Secrétariat"], 
                                         width=25, state="readonly")
        self.e_user_nom = ttk.Entry(left, width=28)
        self.e_user_prenom = ttk.Entry(left, width=28)
        self.e_user_email = ttk.Entry(left, width=28)

        self.e_user_username.grid(row=0, column=1, pady=4)
        self.e_user_password.grid(row=1, column=1, pady=4)
        self.cb_user_role.grid(row=2, column=1, pady=4)
        self.e_user_nom.grid(row=3, column=1, pady=4)
        self.e_user_prenom.grid(row=4, column=1, pady=4)
        self.e_user_email.grid(row=5, column=1, pady=4)

        ttk.Button(left, text="Ajouter", command=self.add_user).grid(row=6, column=1, sticky="e", pady=(10, 0))
        ttk.Button(left, text="Modifier", command=self.update_user).grid(row=6, column=0, sticky="w", pady=(10, 0))

        ttk.Separator(left, orient="horizontal").grid(row=7, column=0, columnspan=2, sticky="ew", pady=12)

        ttk.Button(left, text="Réinitialiser mot de passe", command=self.reset_user_password).grid(row=8, column=0, columnspan=2, sticky="ew", pady=4)
        ttk.Button(left, text="Activer/Désactiver", command=self.toggle_user_active).grid(row=9, column=0, columnspan=2, sticky="ew", pady=4)

        # Section liste des utilisateurs
        right = ttk.LabelFrame(frm, text="Liste des utilisateurs (double-clic = modifier)", padding=10)
        right.pack(side="left", fill="both", expand=True)

        cols = ("id", "username", "role", "nom_prenom", "email", "statut")
        self.tree_users = ttk.Treeview(right, columns=cols, show="headings")
        for c in cols:
            self.tree_users.heading(c, text=c)
            if c == "id":
                self.tree_users.column(c, width=50, anchor="center")
            elif c in ("email", "role"):
                self.tree_users.column(c, width=140, anchor="w")
            else:
                self.tree_users.column(c, width=120, anchor="w")

        self.tree_users.pack(fill="both", expand=True)
        self.tree_users.bind("<Double-1>", self.load_user_to_edit)

    def add_user(self):
        """Ajouter un nouvel utilisateur"""
        username = self.e_user_username.get().strip()
        password = self.e_user_password.get().strip()
        role = self.var_user_role.get()
        nom = self.e_user_nom.get().strip()
        prenom = self.e_user_prenom.get().strip()
        email = self.e_user_email.get().strip()

        if not username or not password:
            messagebox.showerror("Erreur", "Nom d'utilisateur et mot de passe obligatoires.")
            return

        password_hash = hash_password(password)

        conn = db_connect()
        cur = conn.cursor()
        try:
            cur.execute("""
                INSERT INTO users (username, password_hash, role, nom, prenom, email, date_creation, actif)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                username, password_hash, role,
                nom if nom else None,
                prenom if prenom else None,
                email if email else None,
                now_iso(),
                1
            ))
            conn.commit()
            messagebox.showinfo("OK", "Utilisateur ajouté.")
        except sqlite3.IntegrityError:
            messagebox.showerror("Erreur", "Nom d'utilisateur ou email déjà utilisé.")
        finally:
            conn.close()

        # Réinitialiser le formulaire
        self.e_user_username.delete(0, tk.END)
        self.e_user_password.delete(0, tk.END)
        self.e_user_nom.delete(0, tk.END)
        self.e_user_prenom.delete(0, tk.END)
        self.e_user_email.delete(0, tk.END)
        self.var_user_role.set("Secrétariat")
        self.e_user_username.focus()

        self.refresh_users_list()

    def load_user_to_edit(self, event=None):
        """Charger les données d'un utilisateur dans le formulaire pour édition"""
        sel = self.tree_users.selection()
        if not sel:
            return
        
        values = self.tree_users.item(sel[0], "values")
        user_id = int(values[0])

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT username, role, nom, prenom, email FROM users WHERE id=?
        """, (user_id,))
        user = cur.fetchone()
        conn.close()

        if user:
            self.e_user_username.delete(0, tk.END)
            self.e_user_username.insert(0, user[0])
            
            self.var_user_role.set(user[1])
            
            self.e_user_nom.delete(0, tk.END)
            self.e_user_nom.insert(0, user[2] or "")
            
            self.e_user_prenom.delete(0, tk.END)
            self.e_user_prenom.insert(0, user[3] or "")
            
            self.e_user_email.delete(0, tk.END)
            self.e_user_email.insert(0, user[4] or "")

            self.current_edit_user_id = user_id

    def reset_user_password(self):
        """Réinitialiser le mot de passe d'un utilisateur"""
        if not hasattr(self, "current_edit_user_id"):
            messagebox.showerror("Erreur", "Sélectionnez d'abord un utilisateur.")
            return

        new_password = "Password123"
        password_hash = hash_password(new_password)

        conn = db_connect()
        cur = conn.cursor()
        try:
            cur.execute("UPDATE users SET password_hash=? WHERE id=?", (password_hash, self.current_edit_user_id))
            conn.commit()
            messagebox.showinfo("OK", f"Mot de passe réinitialisé à: {new_password}")
        finally:
            conn.close()

        self.refresh_users_list()

    def toggle_user_active(self):
        """Activer/Désactiver un utilisateur"""
        if not hasattr(self, "current_edit_user_id"):
            messagebox.showerror("Erreur", "Sélectionnez d'abord un utilisateur.")
            return
        # Récupérer statut actuel
        conn = db_connect()
        cur = conn.cursor()
        cur.execute("SELECT actif FROM users WHERE id=?", (self.current_edit_user_id,))
        row = cur.fetchone()
        if not row:
            conn.close()
            messagebox.showerror("Erreur", "Utilisateur introuvable.")
            return
        current_actif = row[0]
        new_actif = 0 if current_actif == 1 else 1

        action = "désactiver" if new_actif == 0 else "activer"
        if not messagebox.askyesno("Confirmation", f"{action.capitalize()} cet utilisateur ?"):
            conn.close()
            return

        cur.execute("UPDATE users SET actif=? WHERE id=?", (new_actif, self.current_edit_user_id))
        conn.commit()
        conn.close()

        messagebox.showinfo("OK", f"Utilisateur {'activé' if new_actif==1 else 'désactivé'}.")
        self.refresh_users_list()

    def update_user(self):
        """Valider les modifications d'un utilisateur sélectionné"""
        if not hasattr(self, "current_edit_user_id"):
            messagebox.showerror("Erreur", "Sélectionnez d'abord un utilisateur.")
            return

        username = self.e_user_username.get().strip()
        password = self.e_user_password.get().strip()
        role = self.var_user_role.get()
        nom = self.e_user_nom.get().strip() or None
        prenom = self.e_user_prenom.get().strip() or None
        email = self.e_user_email.get().strip() or None

        conn = db_connect()
        cur = conn.cursor()
        try:
            if password:
                password_hash = hash_password(password)
                cur.execute("UPDATE users SET username=?, password_hash=?, role=?, nom=?, prenom=?, email=? WHERE id=?",
                            (username, password_hash, role, nom, prenom, email, self.current_edit_user_id))
            else:
                cur.execute("UPDATE users SET username=?, role=?, nom=?, prenom=?, email=? WHERE id=?",
                            (username, role, nom, prenom, email, self.current_edit_user_id))
            conn.commit()
            messagebox.showinfo("OK", "Utilisateur mis à jour.")
        except sqlite3.IntegrityError:
            messagebox.showerror("Erreur", "Nom d'utilisateur ou email déjà utilisé.")
        finally:
            conn.close()

        self.refresh_users_list()

    def refresh_users_list(self):
        """Rafraîchir la liste des utilisateurs"""
        if not hasattr(self, "tree_users"):
            return

        for row in self.tree_users.get_children():
            self.tree_users.delete(row)

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT id, username, role, COALESCE(nom,'') || ' ' || COALESCE(prenom,''), 
                   COALESCE(email,''), CASE actif WHEN 1 THEN 'Actif' ELSE 'Inactif' END
            FROM users
            ORDER BY id DESC
        """)
        rows = cur.fetchall()
        conn.close()

        for r in rows:
            self.tree_users.insert("", "end", values=r)

        # Réinitialiser le formulaire
        self.e_user_username.config(state="normal")
        self.e_user_username.delete(0, tk.END)
        self.e_user_password.delete(0, tk.END)
        self.e_user_nom.delete(0, tk.END)
        self.e_user_prenom.delete(0, tk.END)
        self.e_user_email.delete(0, tk.END)
        self.var_user_role.set("Secrétariat")
        if hasattr(self, "current_edit_user_id"):
            del self.current_edit_user_id


# LOGIN WINDOW

class Login(tk.Toplevel):
    def __init__(self, parent):
        super().__init__(parent)
        self.title("Connexion")
        self.geometry("400x220")
        self.resizable(False, False)
        
        # Fermer l'application si on ferme la fenêtre de connexion
        self.protocol("WM_DELETE_WINDOW", self.close_app)

        frm = ttk.Frame(self, padding=12)
        frm.pack(fill="both", expand=True)

        ttk.Label(frm, text="Utilisateur").grid(row=0, column=0, sticky="w", pady=6)
        ttk.Label(frm, text="Mot de passe").grid(row=1, column=0, sticky="w", pady=6)

        self.user = ttk.Entry(frm, width=26)
        self.pwd = ttk.Entry(frm, width=26, show="*")

        self.user.grid(row=0, column=1, pady=6)
        self.pwd.grid(row=1, column=1, pady=6)

        ttk.Button(frm, text="Se connecter", command=self.try_login).grid(row=2, column=1, sticky="e", pady=10)

    def close_app(self):
        """Ferme l'application complètement"""
        self.master.quit()

    def try_login(self):
        username = self.user.get().strip()
        password = self.pwd.get().strip()
        if not username or not password:
            messagebox.showerror("Erreur", "Champs manquants.")
            return

        conn = db_connect()
        cur = conn.cursor()
        cur.execute("""
            SELECT role FROM users
            WHERE username = ? AND password_hash = ? AND actif = 1
        """, (username, hash_password(password)))
        row = cur.fetchone()
        conn.close()

        if not row:
            messagebox.showerror("Erreur", "Identifiants invalides.")
            return

        self.destroy()
        App(self.master, username=username, root=self.master)


# RUN 

if __name__ == "__main__":
    ensure_tables_and_seed()

    root = tk.Tk()
    root.withdraw()

    ttkb.Style(theme="flatly")

    Login(root)
    root.mainloop()
